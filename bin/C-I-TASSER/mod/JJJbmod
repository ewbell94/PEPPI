#!/usr/bin/perl
use Math::Trig;

########### setup  the environment and Working DIRectory ###
#$ENV{'PATH'}="/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/usr/pgi/linux86/bin:";
#$ENV{'LD_LIBRARY_PATH'}="/usr/local/lib:/usr/lib:/lib";

$home="/nfs/amino-home/zhng";
$lib="/nfs/amino-library";
$lib="/oasis/projects/nsf/mia181/zhanglab/library" if(!-d "$lib");
$home="$lib" if (!-d "$home");
 
################# directories #############################
$data_dir="!DATA_DIR!/!S!";  #for seq.txt and init.dat
#$work_dir="/tmp/!USER!/!TAG!";
$work_dir="/scratch/$ENV{USER}/$ENV{SLURM_JOBID}";
$work_dir="/tmp/!USER!/!TAG!" if (!-d "$work_dir" || ! "$ENV{SLURM_JOBID}");

$libdir="!LIB_DIR!";
$psipreddir="$lib/bin/psipred";
$blastdir="$lib/blast/bin"; #blast always uses local
$db="$lib/nr/nr";
$absdir="$lib/abs";

##### report node -------->
`hostname`=~/(\S+)/;
$node=$1;
printf "hostname: $node\n";
$time=`date`;
printf "starting time: $time";
$pwd=`pwd`;
printf "pwd: $pwd";
%ts=(
     'GLY'=>'G',
     'ALA'=>'A',
     'VAL'=>'V',
     'LEU'=>'L',
     'ILE'=>'I',
     'SER'=>'S',
     'THR'=>'T',
     'CYS'=>'C',
     'MET'=>'M',
     'PRO'=>'P',
     'ASP'=>'D',
     'ASN'=>'N',
     'GLU'=>'E',
     'GLN'=>'Q',
     'LYS'=>'K',
     'ARG'=>'R',
     'HIS'=>'H',
     'PHE'=>'F',
     'TYR'=>'Y',
     'TRP'=>'W',

     'ASX'=>'B',
     'GLX'=>'Z',
     'UNK'=>'X',

     'G'=>'GLY',
     'A'=>'ALA',
     'V'=>'VAL',
     'L'=>'LEU',
     'I'=>'ILE',
     'S'=>'SER',
     'T'=>'THR',
     'C'=>'CYS',
     'M'=>'MET',
     'P'=>'PRO',
     'D'=>'ASP',
     'N'=>'ASN',
     'E'=>'GLU',
     'Q'=>'GLN',
     'K'=>'LYS',
     'R'=>'ARG',
     'H'=>'HIS',
     'F'=>'PHE',
     'Y'=>'TYR',
     'W'=>'TRP',

     'a'=>'CYS',
     'b'=>'CYS',
     'c'=>'CYS',
     'd'=>'CYS',
     'e'=>'CYS',
     'f'=>'CYS',
     'g'=>'CYS',
     'h'=>'CYS',
     'i'=>'CYS',
     'j'=>'CYS',
     'k'=>'CYS',
     'l'=>'CYS',
     'm'=>'CYS',
     'n'=>'CYS',
     'o'=>'CYS',
     'p'=>'CYS',
     'q'=>'CYS',
     'r'=>'CYS',
     's'=>'CYS',
     't'=>'CYS',
     'u'=>'CYS',
     'v'=>'CYS',
     'w'=>'CYS',
     'x'=>'CYS',
     'y'=>'CYS',
     'z'=>'CYS',

     'B'=>'ASX',
     'Z'=>'GLX',
     'X'=>'CYS',
    );
################ working directory ########################
`/bin/mkdir -p $work_dir`;
chdir "$work_dir";
`/bin/rm -f $work_dir/*`;
`cp $data_dir/seq.txt .`;
`cp $libdir/bin/align ./align`;
`cp $lib/abs/mybin/dalign3 ./dalign`;
 
@seqtxts=`cat seq.txt`;
$sequence="";
foreach $seqtxt(@seqtxts)
{
    goto pos6 if($seqtxt=~/\>/);
    $seqtxt=~s/\s//mg;
    $seqtxt=~s/\n//mg;
    $sequence=$sequence.$seqtxt;
  pos6:;
}
$Lch=length $sequence;
for($i=1;$i<=$Lch;$i++){
    $a=substr($sequence,$i-1,1);
    $seqQ{$i}=$a;   #only for check
}

printf "run psiblast 0.001\n";
system("$home/bin/blast+.pl seq.txt");

printf "run psipred\n";
$Pdatadir="$psipreddir/data";
`$psipreddir/bin/psipred mtx $Pdatadir/weights.dat $Pdatadir/weights.dat2 $Pdatadir/weights.dat3 $Pdatadir/weights.dat4 > protein.ss`;
`$psipreddir/bin/psipass2 $Pdatadir/weights_p2.dat 1 1.0 1.0 protein.ss2 protein.ss > protein.horiz`;
`/bin/cp protein.ss2 seq.dat.ss`;

######### convert seq.dat.ss into the format that dalign can recognize -------->
printf "run reformat psipred\n";
open(seqss,"seq.dat.ss");
$k=0;
while($line=<seqss>){
    if($line=~/\d+\s+(\S)\s+(\S)\s+(\S+)\s+(\S+)\s+(\S+\.\S+)/){
	$k++;
	$LINE{$k}=$line;
    }
}
close(seqss);
open(seqss,">seq.dat.ss");
print seqss "# PSIPRED VFORMAT (PSIPRED V2.6 by David Jones)\n\n";
for($i=1;$i<=$k;$i++){
    print seqss "$LINE{$i}";
}
close(seqss);

printf "sol.txt...\n";
if(!-s "$data_dir/sol.txt"){
    printf "run solvent\n";
    `$absdir/mybin/getannfeature 10 psitmp.chk seq.dat.ss annfeat10.dat`;
    `$absdir/mybin/simple_onetestsas 10 60 $absdir/mybin/sastrainres10-60.net annfeat10.dat sol.txt`;
    #`cp sol.txt $data_dir/`;
}else{
    `cp $data_dir/sol.txt .`;
}

printf "blast1.0....\n";
if(!-s "$data_dir/blast1.0.out"){
    printf "run psiblast 1.0\n";
    `$blastdir/blastpgp -i seq.txt -b 1000 -j 3 -h 1.0 -d $db > blast1.0.out`;
    #`cp blast1.0.out $data_dir/`;
}else{
    `cp $data_dir/blast1.0.out .`;
}

printf "pro2 blast.out....\n";
$rst=`$lib/abs/mybin/calcneffblapro2 seq.txt blast.out 0.001`;
$rst=~/(\S+)\s+(\S+)/;
$neffval1=$2;

printf "pro2 blast1.0.out ....\n";
$rst=`$lib/abs/mybin/calcneffblapro2 seq.txt blast1.0.out 1.0`;
$rst=~/(\S+)\s+(\S+)/;
$neffval2=$2;
printf "neff $neffval1 $neffval2\n";

########### run dalign #############
open(in,">in.dd");
printf in "seq.txt\n";#0
printf in "seq.dat.ss\n";#1
printf in "blast.out\n";#2
printf in "mtx\n";#3
printf in "blast1.0.out\n";#4
printf in "sol.txt\n";#5
printf in "$libdir/PDB/list\n";#6
printf in "$libdir/summary/AAA.seq\n";#7
printf in "$libdir/summary/AAA.sec\n";#8
printf in "$libdir/abs/AAA.sol\n";#9
printf in "$libdir/MTX\n";#10
printf in "$libdir/abs/blapro\n";#11
printf in "$libdir/abs/blapro1\n";#12
close(in);

printf "running dalign .....\n";
`./dalign`;


################ calculate Z-score ######################
open(out,"rst.dat");
$i=0;
while($line=<out>)
{
    if($line=~/(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/)
    {
	$i++;
	$p{$i}=$2;
	$v3{$i}=$4;
	$neff{$p{$i}}=$5;
	$v3_a+=$v3{$i};
	$v3_a2+=$v3{$i}**2;
    }
}
close(out);
$N_hit=$i;
$v3_a/=$N_hit;
$v3_a2/=$N_hit;
$sd=sqrt($v3_a2-$v3_a**2);
for($i=1;$i<=$N_hit;$i++)
{
    $zscore{$p{$i}}=($v3{$i}-$v3_a)/$sd;
}
@zscore_keys=sort{$zscore{$b}<=>$zscore{$a}} keys %zscore;

###########################################################
##### create template file 'init.dat' #####################
###########################################################
open(init,">init.dat");

$i_t=0;
for($i=1;$i<=$N_hit;$i++)
{
    $template_name=$zscore_keys[$i-1];
    $template_name=~s/\./\\\./mg;  #useful for match
    $zscore_value=$zscore{$zscore_keys[$i-1]};
    $neff_value=$neff{$zscore_keys[$i-1]};
    ######## read the alignment -------->
    open(align,"align.dat");
    while($line=<align>)
    {
	if($line=~/structureX:$template_name\s/)
	{         
	    $line1=<align>;
	    $line1=~/(\S+)/;
	    $sequenceQ=$1;#query sequence
	    $line1=<align>;
	    $line1=<align>;
	    $line1=<align>;
	    $line1=<align>;
	    $line1=~/(\S+)/; 
	    $sequenceT=$1;#template sequence     
	    goto pos1;
	}
    }
  pos1:;
    close(align);
    ####### get sequence identity of the alignment ------>
    $L=length $sequenceQ;
    $L_eq=0;  #number of identical residues
    $L_ali=0; #number of aligned residues
    for($j=1;$j<=$L;$j++)
    {
	$sQ=substr($sequenceQ,$j-1,1);
	$sT=substr($sequenceT,$j-1,1);
	if($sQ ne "-" && $sT ne "-")
	{
	    $L_ali++;
	    if($sQ eq $sT)
	    {
		$L_eq++;
	    }
	}
    }
    $seq_id=$L_eq/($L_ali+.0000001); #seq idendity betwen target & template
    
    ####### read template conformation #################
  pos2a:;
    if(-s "$libdir/PDB/$template_name\.pdb"){
	`/bin/cp $libdir/PDB/$template_name\.pdb ./temp.pdb`;
    }else{
	sleep(2);
	goto pos2a;
    }
    $idcut0=!ID_CUT!;
    if($idcut0<0.999)
    {
	$align_rst=`./align seq.txt temp.pdb 2`;
	if($align_rst=~/Identical length\:\s+(\d+)/)
	{
	    $id=$1/$Lch;
	    goto pos2 if($id>=$idcut0);
	}
    }
    $i_t++;

    open(temppdb,"temp.pdb");
    $n=0;
    while($line=<temppdb>)
    {
	$ATOM=substr($line,0,4);
	$atom=substr($line,12,4);
	$atom=~s/\s//mg;
	if( $ATOM eq "ATOM" && $atom eq "CA")
	{
	    $n++;
	    $seqT{$n}=$ts{substr($line,17,3)}; #only for check
	      $numT{$n}=substr($line,22,4);
	    $x{$n}=substr($line,30,8);
	    $y{$n}=substr($line,38,8);
	    $z{$n}=substr($line,46,8);
	}
    }
    close(temppdb);

    ########## write alignment to 'init.dat' ------------------>
    $a=substr($template_name,0,4);
    if(length $template_name == 4)
    {
	$b="_";
    }
    else
    {
	$b=substr($template_name,4,1);
	$b=~tr/a-z/A-Z/;
    }
    $temp_name="$a$b";
    $template_name=~s/\\\./\./mg;
    printf init "%5d %8.3f %5d   %6s %8.3f %8.3f(=$L_ali/$Lch) (L_ali,Z,i,pdb,id,cov) %6.3f\n",
    $L_ali,$zscore_value,$i_t,$template_name,$seq_id,$L_ali/$Lch,$neff_value;
    $iQ=0;
    $iT=0;
    for($j=1;$j<=$L;$j++){
	$sQ=substr($sequenceQ,$j-1,1);
	$sT=substr($sequenceT,$j-1,1);
	if($sQ eq "-")
	{
	    $iT++;
	}
	if($sT eq "-")
	{
	    $iQ++;
	}
	if($sQ ne "-" && $sT ne "-")
	{
	    $iQ++;
	    $iT++;
	    printf init "ATOM  %5s  CA  %3s  %4d    %8.3f%8.3f%8.3f%5s %3s\n",
	    $iQ,$ts{$sQ},$iQ,$x{$iT},$y{$iT},$z{$iT},$numT{$iT},$ts{$sT};
	    if($sQ ne $seqQ{$iQ} || $sT ne $seqT{$iT})
	    {
		print "$temp_name: $iQ - $sQ = $seqQ{$iQ} <> $iT - $sT = $seqT{$iT}\n";
	    }
	}
    }
    printf init "TER\n";
    goto pos3 if($i_t >= !N_TEMP!);
  pos2:;
}
 pos3:;
$time=`/bin/date`;
close(init);

open(init1,">init1.dat");
printf init1 "%5d %5d (N_temp, Lch) %6.3f %6.3f\n",$i_t,$Lch,$neffval1,$neffval2;
close(init1);
`cat init.dat >> init1.dat`;

`/bin/cp init1.dat            $data_dir/init!O!.JJJb`;
################# endding procedure ######################
posend:;
$time=`date`;
printf "ending time: $time";
`sync`;

sleep(1);
`rm -fr $work_dir`;

exit();

