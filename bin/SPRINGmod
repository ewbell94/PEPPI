#!/usr/bin/env perl

use strict;
use warnings;
use Scalar::Util qw(looks_like_number);
use List::Util qw(min);
use POSIX qw(floor);

my $peppidir="!PEPPIDIR!"; #Location of PEPPI program files (used for binary programs)
my $outdir="!OUTDIR!/PPI"; #Location of PPI pair files
my $pairname="!PAIRNAME!"; #Name of PPI to run in
my $benchmarkflag=!BENCHMARK!; #Set to 1 to run in "benchmark mode" (templates < 30% seq id removed), otherwise 0

print `mkdir $outdir/$pairname/SPRING`;

#User-set parameters
my $bindir="$peppidir/bin"; #location of program binaries
my $springout="$outdir/$pairname/SPRING"; #location of program output
my $dbdir="/nfs/amino-home/liuzi/lz_program/TACOS/database"; #location of SPRING database
my $maxmodels=3; #maximum number of model pdb files to make
my $scut=($benchmarkflag) ? 0.3 : 1.1; #monomeric sequence homology cutoffs for threading; 0.3="benchmark", 1.1="real"
my $uniprotdb="/nfs/amino-library/local/hhsuite/uniprot20_2016_02/uniprot20_2016_02"; #location of Uniprot database for HHblits search
my $dimerdb="/nfs/amino-library/DIMERDB/HHsearch/hhm.db"; #location of dimer chain template database for HHsearch threading
my $zmin=2.0; #Minimum Z-score for reporting templates; if none are found satisfying this threshold, zmin is set to -5
my $hhdir="$outdir/../hhr"; #location of hhr files of previously run HHsearch results

#DO NOT CHANGE BENEATH THIS LINE UNLESS YOU KNOW WHAT YOU ARE DOING
#Processed parameters
my $user=`whoami`;
chomp($user);
$ENV{'HHLIB'}="$bindir/hhsuite/"; #necessary for proper function of HHsearch
my @weights=(1,12.0,-1.4); #weights for SPRING score calculation
my $homothresh=0.9; #interchain sequence id threshold for detecting homodimers
my $seqmax=1500; #maximum allowable length of input sequences; sequences longer than this will be truncated
my $minmono=5000; #number of monomer templates for dimer matching
my $dimercount=100; #number of dimers to be assembled
my $topcount=$dimercount;
my $topscore=-100.0;

#Check if SPRING has already produced a result
if (-e "$springout/res.txt"){
    print "SPRING has already been run!\n";
    exit(2);
}

#Read in the list of complexes from the database
open(my $complexfile,"<","$dbdir/pdb/ComplexList.txt");
my %complexlist=(); #Find all potential partner chains given some core chain
while (my $line=<$complexfile>){
    chomp($line);
    my @chains=split("-",$line);
    if (exists($complexlist{$chains[0]})){
	push(@{$complexlist{$chains[0]}},$chains[1]);
    } else {
	my @value=($chains[1]);
	$complexlist{$chains[0]}=\@value;
    }
}
close($complexfile);

#Read the "index" file from the database
#
#This file can be interpreted as follows: if the monomer chain in the left column is hit, add the right and
#middle column to consideration for finding dimers
open(my $indexfile,"<","$dbdir/SPRING/index.txt");
my %forwardindex=(); #Search for the HHsearch template of a given chain
my %reverseindex=(); #Search for chains assigned to a given HHsearch template
while (my $line=<$indexfile>){
    chomp($line);
    my @parts=split(' ',$line);
    $forwardindex{"$parts[0]/$parts[1]"}=$parts[2];
    if (exists($reverseindex{$parts[2]})){
	push(@{$reverseindex{$parts[2]}},"$parts[0]/$parts[1]");
    } else {
	my @value=("$parts[0]/$parts[1]");
	$reverseindex{$parts[2]}=\@value;
    }
}
close($indexfile);

#Given the set of domains, run SPRING between all possible pairs
my @qseqs=split("-",$pairname);
my @domainPairs=();
my $m=1;
while (-e "$outdir/$pairname/$qseqs[0]\_$m.seq"){
    my $n=1;
    while (-e "$outdir/$pairname/$qseqs[1]\_$n.seq"){
	my @domainPair=("$qseqs[0]\_$m","$qseqs[1]\_$n");
	push(@domainPairs,\@domainPair);
	$n++;
    }
    $m++;
}

#Establish working directory
my $randomTag=int(rand(1000000)); #This is to prevent multiple instances from deleting eachother's directories
my $tempdir="/tmp/$user/PEPPI_SPRING_$qseqs[0]-$qseqs[1]\_$randomTag";
if (! -e "$tempdir"){
    print `mkdir -p $tempdir`;
} else {
    print `rm -rf $tempdir/*`;
}
chdir("$tempdir");

#For each pair of domains, run SPRING
for my $pointer (@domainPairs){
    
    #Sanitize input
    my @qdoms = @{$pointer};
    my $prot1file="$outdir/$pairname/$qdoms[0].seq";
    my $prot2file="$outdir/$pairname/$qdoms[1].seq";
    my $prot1=$qdoms[0];
    my $prot2=$qdoms[1];
    
    my $outputdir="$springout/$qdoms[0]-$qdoms[1]";
    print `mkdir $outputdir`;
    if (! -e "$prot1file" || ! -e "$prot2file"){
	print "Protein sequence files were not found!\n";
	next;
    }
    
    print `cp $prot1file $tempdir/$prot1.fasta`;
    print `cp $prot2file $tempdir/$prot2.fasta`;
    
    #Copy HHR files or run HHsearch
    print "Running HHsearch\n";
    if (-e "$hhdir/$prot1.hhr"){
	print `cp $hhdir/$prot1.hhr $tempdir`;
    } else {
	makeHHR($prot1);
	if (! -e "$tempdir/$prot1.hhr"){
	    print "HHsearch failed for $prot1.\n";
	    exit(4);
	} else {
	    print `cp $tempdir/$prot1.hhr $outputdir/$prot1.hhr`;
	}
    }
    if (-e "$hhdir/$prot2.hhr"){
	print `cp $hhdir/$prot2.hhr $tempdir`;
    } else {
	makeHHR($prot2);
	if (! -e "$tempdir/$prot2.hhr"){
	    print "HHsearch failed for $prot2.\n";
	    exit(4);
	} else {
	    print `cp $tempdir/$prot2.hhr $outputdir/$prot2.hhr`;
	}
    }
    
    #Fetch HHsearch hits from HHR files
    print "Fetching HHsearch hits\n";
    my @prot1hits=fetchHits($prot1);
    my @prot2hits=fetchHits($prot2);
    
    #Store dfire 
    #open(my $dfirefile,"<","$bindir/dfire.txt");
    #open(my $dfirefile,"<","$bindir/newdfire.txt");
    #my @dfire=<$dfirefile>;
    #chomp(@dfire);
    #close($dfirefile);
    
    #Search for dimer templates given monomeric hits
    my @dimerTemplates=fetchDimers(\@prot1hits,\@prot2hits,\%complexlist);
    
    #Flip the sequence order and search for more dimer templates if the chains are nonidentical
    if (getSeqID("$tempdir/$prot1.fasta","$tempdir/$prot2.fasta") < $homothresh){
	my @flippedTemplates=fetchDimers(\@prot2hits,\@prot1hits,\%complexlist);
	for my $i (0..scalar(@flippedTemplates)-1){
	    my $dupflag=0;
	    for my $j (0..scalar(@dimerTemplates)-1){
		if ($dimerTemplates[$j][0] eq $flippedTemplates[$i][1] && $dimerTemplates[$j][1] eq $flippedTemplates[$i][0]){
		    $dupflag=1;
		    last;
		}
	    }
	    if (!$dupflag){
		my @flipped=($flippedTemplates[$i][1],$flippedTemplates[$i][0],$flippedTemplates[$i][2]);
		push(@dimerTemplates,\@flipped);
	    } else {
		print "Duplicate purged: $flippedTemplates[$i][0] $flippedTemplates[$i][1]\n";
	    }
	}
    }
    
    #Order dimer templates by Z-score
    @dimerTemplates=sort{$b->[2]<=>$a->[2]} @dimerTemplates;
    
    #Create and score models from selected dimer templates
    
    print "Constructing models\n";
    
    constructMonomer($prot1,$prot1hits[0][0]);
    print `cp $tempdir/$prot1.pdb $outputdir/$prot1.pdb`;
    constructMonomer($prot2,$prot2hits[0][0]);
    print `cp $tempdir/$prot2.pdb $outputdir/$prot2.pdb`;
    
    my $hhr1head=`head $tempdir/$prot1.hhr`;
    $hhr1head=~/Match_columns\s+(\d+)/;
    my $seq1len=$1;
    my $hhr2head=`head $tempdir/$prot2.hhr`;
    $hhr2head=~/Match_columns\s+(\d+)/;
    my $seq2len=$1;
    
    if (scalar(@dimerTemplates)==0){
	print "No dimer templates found!\n";
	exit(0);
    }

    my @dimerModels=();
    for my $i (0..min(scalar(@dimerTemplates)-1,$dimercount-1)){
	print "$dimerTemplates[$i][0]-$dimerTemplates[$i][1]\n";
	my @scores=constructModel($prot1,$prot2,$dimerTemplates[$i][0],$dimerTemplates[$i][1],$dimerTemplates[$i][2],$seq1len,$seq2len);
	my @model=($dimerTemplates[$i][0],$dimerTemplates[$i][1],\@scores);
	push(@dimerModels,\@model);
    }
    
    #Sort dimer models by SPRINGscore and write TemplateSummary.txt
    @dimerModels=sort{$b->[2][0]<=>$a->[2][0]} @dimerModels;
    
    my $domainscore=$dimerModels[0][2][0];
    $topscore=$domainscore if ($domainscore>$topscore);

    #The template summary file is formatted as follows:
    #ChainAname    ChainBname   SPRINGscore    Z-score    TM-score    DCOMPLEX
    print "Writing output\n";
    open(my $summary,">","$outputdir/TemplateSummary.txt");
    for my $i (0..min(scalar(@dimerModels)-1,$topcount-1)){
	(my $dimer1name=$dimerModels[$i][0])=~s/\//_/g;
	(my $dimer2name=$dimerModels[$i][1])=~s/\//_/g;
	print `cp $tempdir/$dimer1name-$dimer2name.pdb $outputdir/model$i.pdb` if ($i < $maxmodels);
	print $summary sprintf("%s\t%s\t%.3f\t%.3f\t%.3f\t%.3f\n",$dimerModels[$i][0],$dimerModels[$i][1],$dimerModels[$i][2][0],$dimerModels[$i][2][1],$dimerModels[$i][2][2],$dimerModels[$i][2][3]);
    }
    close($summary);

    print `sync`;
    print `rm -rf $tempdir/*`;
}

#Clean temporary directory and collect top-scoring domain pair
print `rm -rf $tempdir`;
open(my $resfile,">","$outdir/$pairname/SPRING/res.txt");

if ($topscore==-100.0){
    print $resfile "?\n";
} else {
    print $resfile "$topscore\n";
}

#getSeqID returns the sequence identity of two chains using the NWalign program
sub getSeqID{
    my $fname1=$_[0];
    my $fname2=$_[1];
    return 0.0 if (! -f $fname1 || ! -f $fname2);
    my $NWresult;
    if ($fname2=~/\.fasta/){
	$NWresult=`$bindir/NWalign $fname1 $fname2`;
    } elsif ($fname2=~/\.pdb/){
	$NWresult=`$bindir/NWalign $fname1 $fname2 2`;
    } else {
	return 0.0;
    }
    $NWresult=~/Identical length:\s+(\d+)/;
    my $idcount=$1;
    $NWresult=~/Length of sequence 1:\s+(\d+).*\nLength of sequence 2:\s+(\d+)/;
    my $seq1len=$1;
    my $seq2len=$2;
    return min($idcount/$seq1len,$idcount/$seq2len) if ($fname2=~/\.fasta/);
    return $idcount/$seq1len if ($fname2=~/\.pdb/);
    return 0.0;
}

#makeHHR threads a query sequence through DIMERDB using HHsearch
sub makeHHR{
    my $prot=$_[0];
    print `$bindir/hhsuite/bin/hhblits -i $tempdir/$prot.fasta -oa3m $tempdir/$prot.a3m -d $uniprotdb -n 2 -e 0.001`;
    print `$bindir/hhsuite/scripts/addss.pl $tempdir/$prot.a3m`;
    print `$bindir/hhsuite/bin/hhmake -i $tempdir/$prot.a3m -id 90 -diff 100 -cov 0 -qid 0`;
    print `$bindir/hhsuite/bin/hhsearch -i $tempdir/$prot.hhm -d $dimerdb -id 90 -diff 100 -cov 0 -qid 0 -e 0.001 -p 20 -E 0.01 -Z 30000 -z 20000 -B 30000 -b 20000`;
    print `cp $tempdir/$prot.hhr $hhdir/$prot.hhr`;
}

#fetchHits reads an HHsearch results and retrieves the top monomers and their corresponding Z-scores
sub fetchHits{
    my $prot=$_[0];
    my @templates=();
    my @scores=();
    open(my $hhrfile,"<","$tempdir/$prot.hhr");
    while (my $line=<$hhrfile>){
	if (substr($line,0,1) eq ">"){
	    my $target=substr($line,1,5);
	    next if (grep(/$target/,@templates));
	    push(@templates,$target);
	    my $scoreline=<$hhrfile>;
	    $scoreline=~/Sum_probs=(\S+)/;
	    my $score=$1;
	    #print "$target,$score\n";
	    push(@scores,$score);
	}
    }
    close($hhrfile);
    
    my $meanval=0.0;
    for my $score (@scores){
	$meanval+=$score/scalar(@scores);
    }
    my $std=0.0;
    for my $score (@scores){
	$std+=($score-$meanval)**2/scalar(@scores);
    }
    $std=$std**(0.5);
    
    my @pairs=();
    for my $i (0..scalar(@templates)-1){
	my @pair=($templates[$i],($scores[$i]-$meanval)/$std);
	push(@pairs,\@pair);
    }
    @pairs=sort{$b->[1]<=>$a->[1]} @pairs;
    
    my @outlist=();
    my $i=0;
    while(scalar(@outlist) < $minmono && $i < scalar(@pairs)){
	if ($scut<1.0){
	    push(@outlist,$pairs[$i]) if (getSeqID("$tempdir/$prot.fasta","$dbdir/pdb/chains/".substr($pairs[$i][0],1,2)."/$pairs[$i][0].pdb") < $scut);
	} else {
	    push(@outlist,$pairs[$i]);
	}
	$i++;
    }
    return @outlist;
}

#fetchDimers retrieves potential dimer templates given the two chains' monomer hits
sub fetchDimers{
    print "Fetching dimers\n";
    my @prot1list=@{$_[0]};
    my @prot2list=@{$_[1]};
    my %complexlist=%{$_[2]};
    my @dimerlist=();
    for my $i (0..scalar(@prot1list)-1){
	next if (!exists($reverseindex{$prot1list[$i][0]}));
	my @prot1hits=@{$reverseindex{$prot1list[$i][0]}};
	print "$prot1list[$i][0]\n";
	for my $biomol1 (@prot1hits){
	    next if ($biomol1=~/_1_/);
	    my @prot1complexes=@{$complexlist{$biomol1}};
	    for my $partner (@prot1complexes){
		next if (!exists($forwardindex{$partner}));
		my $prot2hit=$forwardindex{$partner};
		for my $j (0..scalar(@prot2list)-1){
		    if ($prot2list[$j][0] eq $prot2hit){
			my $zscore=min($prot1list[$i][1],$prot2list[$j][1]);
			my @dimerpair=($biomol1,$partner,$zscore);
			push(@dimerlist,\@dimerpair);
			last;
		    }
		}
	    }
	}
    }
    return @dimerlist;
}

#constructMonomer will build a model of the top-ranked monomer for a given chain (for superposition)
sub constructMonomer{
    my $query=$_[0];
    my $template=$_[1];
    my $templatesub=substr($template,1,2);
    my %onetothree=('A'=>"ALA",'C'=>"CYS",'D'=>"ASP",'E'=>"GLU",'F'=>"PHE",
		    'G'=>"GLY",'H'=>"HIS",'I'=>"ILE",'K'=>"LYS",'L'=>"LEU",
		    'M'=>"MET",'N'=>"ASN",'P'=>"PRO",'Q'=>"GLN",'R'=>"ARG",
		    'S'=>"SER",'T'=>"THR",'V'=>"VAL",'W'=>"TRP",'Y'=>"TYR",
		    'B'=>"BBB",'Z'=>"ZZZ",'X'=>"XYZ",'U'=>"SEC",'O'=>"PYL");
    
    my @alignment=();
    my @qaa=();
    open(my $hhresultfile,"<","$tempdir/$query.hhr");
    my $readflag=0;
    while (my $line=<$hhresultfile>){
	if ($line=~/>$template/){
	    while(1){
		for my $i (0..3){
		    $line=<$hhresultfile>;
		    last if ($line=~/Done!/);
		}
		last if (!($line=~/^Q/));
		#print "Query line:\n";
		#print $line;
		$line=~/Q .*\s(\d+) (\S+)\s+\d+ \(/;
		my $startq=$1;
		my $qseq=$2;
		#print "$startq,$qseq,test\n";
		for my $i (0..3){
		    $line=<$hhresultfile>;
		}
		#print "Template line:\n";
		#print $line;
		$line=~/T .*\s(\d+) (\S+)\s+\d+ \(/;
		my $startt=$1;
		my $tseq=$2;
		#print "$startt,$tseq,test\n";
		while (scalar(@qaa)<$startq){
		    push(@qaa,"XYZ");
		}
		while (scalar(@alignment)<$startt){
		    push(@alignment,-1);
		}
		print "Error: different sequnce lengths\n" if (length($qseq) != length($tseq));
		for my $i (0..length($qseq)-1){
		    my $qchar=substr($qseq,$i,1);
		    my $tchar=substr($tseq,$i,1);
		    if ($qchar eq "-"){
			push(@alignment,-1);
		    } elsif ($tchar eq "-") {
			if ($onetothree{$qchar} ne ""){
			    push(@qaa,$onetothree{$qchar});
			} else {
			    push(@qaa,"UNK");
			}
			$startq++;
		    } else {
			if ($onetothree{$qchar} ne ""){
			    push(@qaa,$onetothree{$qchar});
			} else {
			    push(@qaa,"UNK");
			}
			push(@alignment,$startq);
			$startq++;
		    }
		}
		for my $i (0..1){
		    $line=<$hhresultfile>;
		}
	    }
	    last;
	}
	
    }
    close($hhresultfile);
    
    open(my $modelout,">","$tempdir/$query.pdb");
    open(my $tempin,"<","$dbdir/pdb/chains/$templatesub/$template.pdb");
    my $i=1;
    while (my $line=<$tempin>){
	next if (substr($line,0,4) ne "ATOM" || substr($line,12,4) ne " CA ");
	my $resnum=substr($line,22,4);
	next if ($resnum >= scalar(@alignment) || $alignment[$resnum] < 0);
	my $resname=substr($line,17,3);
	chomp($line);
	substr($line,17,3)=$qaa[$alignment[$resnum]];
	substr($line,6,5)=sprintf("%5s",$resnum);
	substr($line,22,4)=sprintf("%4s",$alignment[$resnum]);
	$line=$line.sprintf("%5s",$resnum).sprintf(" %s",$resname);
	print $modelout "$line\n";
	$i++;
    }
    for my $j (1..$i-1){
	my $connection=sprintf("CONECT%5s%5s\n",$j,$j+1);
	#print $modelout $connection;
    }
    close($modelout);
    close($tempin);
}

#constructModel will construct and score a dimer model given two monomer structures and a dimer template
sub constructModel{
    my $prot1=$_[0];
    my $prot2=$_[1];
    my $dimer1temp=$_[2];
    my $dimer2temp=$_[3];
    my $zscore=$_[4];
    my $seq1len=$_[5];
    my $seq2len=$_[6];

    my $dimer1sub=substr($dimer1temp,1,2);
    my $dimer2sub=substr($dimer2temp,1,2);

    (my $dimer1name=$dimer1temp)=~s/\//_/g;
    (my $dimer2name=$dimer2temp)=~s/\//_/g;
    open(my $modelfile,">","$tempdir/$dimer1name-$dimer2name.pdb");
    
    #Construct the model by superposition; store the TM-score result
    my $TM1result=`$bindir/TMalign "$tempdir/$prot1.pdb" "$dbdir/pdb/PDBall/$dimer1sub/$dimer1temp.pdb" -L $seq1len -o $tempdir/out`;
    #print "$TM1result\n";
    print `grep "^ATOM.* A .*" $tempdir/out > $tempdir/temp1.pdb`;
    $TM1result=~/TM-score= (.*) \(if scaled/;
    my $tm1score=$1;
    #print "$tm1score\n";
    my $end1ind=0;
    open(my $supfile,"<","$tempdir/out_all");
    while (my $line=<$supfile>){
	last if ($line=~/^TER/);
	if ($line=~/^ATOM/){
	    $end1ind=substr($line,6,5);
	    print $modelfile $line;
	}
    }
    print $modelfile "TER\n";
    close($supfile);

    my $TM2result=`$bindir/TMalign "$tempdir/$prot2.pdb" "$dbdir/pdb/PDBall/$dimer2sub/$dimer2temp.pdb" -L $seq2len -o $tempdir/out`;
    #print "$TM2result\n";
    print `grep "^ATOM.* A .*" $tempdir/out > $tempdir/temp2.pdb`;
    $TM2result=~/TM-score= (.*) \(if scaled/;
    my $tm2score=$1;
    #print "$tm2score\n";
    my $end2ind=$end1ind;
    open($supfile,"<","$tempdir/out_all");
    while (my $line=<$supfile>){
	last if ($line=~/^TER/);
	if ($line=~/^ATOM/){
	    substr($line,21,1)="B";
	    $end2ind=$end1ind+substr($line,6,5);
	    substr($line,6,5)=sprintf("%5s",$end2ind);
	    print $modelfile $line;
	}
    }
    print $modelfile "TER\n";
    close($supfile);

    for my $i (1..$end1ind-1){
	my $connectline=sprintf("CONECT%5s%5s\n",$i,$i+1);
	print $modelfile $connectline;
    }
    for my $i ($end1ind+1..$end2ind-1){
	my $connectline=sprintf("CONECT%5s%5s\n",$i,$i+1);
	print $modelfile $connectline;
    }
    close($modelfile);

    #run DCOMPLEX to evaluate the interface energy
    my $dfire=`$bindir/dcomplex $tempdir/$dimer1name-$dimer2name.pdb A B`;
    #$dfire=-4.7 if (!looks_like_number($dfire));
    print "$dfire";

    #compile scores and calculate SPRINGscore
    my $tmscore=min($tm1score,$tm2score);
    my $springscore=$weights[0]*$zscore+$weights[1]*$tmscore+$weights[2]*$dfire;
    #print "$zscore,$tmscore,$dfire,$springscore\n\n";
    my @scores=($springscore,$zscore,$tmscore,$dfire);
    return @scores;
}
