#!/usr/bin/perl
use Math::Trig;

# download location: http://sparks-lab.org/yueyang/download/SPARKS-X/

############### SPARKX threading ############################

$ENV{'PATH'}="/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/usr/pgi/linux86/bin";
$ENV{'LD_LIBRARY_PATH'}="/usr/local/lib:/usr/lib:/lib";

$lib="/nfs/amino-library";

##### report node -------->
`hostname`=~/(\S+)/;
$node=$1;
printf "hostname: $node\n";
$time=`date`;
printf "starting time: $time";
$pwd=`pwd`;
printf "pwd: $pwd";
#^^^^^^^^^^^^^^^^^^^^^^^^^^

%ts=(
     'GLY'=>'G',
     'ALA'=>'A',
     'VAL'=>'V',
     'LEU'=>'L',
     'ILE'=>'I',
     'SER'=>'S',
     'THR'=>'T',
     'CYS'=>'C',
     'MET'=>'M',
     'PRO'=>'P',
     'ASP'=>'D',
     'ASN'=>'N',
     'GLU'=>'E',
     'GLN'=>'Q',
     'LYS'=>'K',
     'ARG'=>'R',
     'HIS'=>'H',
     'PHE'=>'F',
     'TYR'=>'Y',
     'TRP'=>'W',

     'ASX'=>'B',
     'GLX'=>'Z',
     'UNK'=>'X',

     'G'=>'GLY',
     'A'=>'ALA',
     'V'=>'VAL',
     'L'=>'LEU',
     'I'=>'ILE',
     'S'=>'SER',
     'T'=>'THR',
     'C'=>'CYS',
     'M'=>'MET',
     'P'=>'PRO',
     'D'=>'ASP',
     'N'=>'ASN',
     'E'=>'GLU',
     'Q'=>'GLN',
     'K'=>'LYS',
     'R'=>'ARG',
     'H'=>'HIS',
     'F'=>'PHE',
     'Y'=>'TYR',
     'W'=>'TRP',

     'a'=>'CYS',
     'b'=>'CYS',
     'c'=>'CYS',
     'd'=>'CYS',
     'e'=>'CYS',
     'f'=>'CYS',
     'g'=>'CYS',
     'h'=>'CYS',
     'i'=>'CYS',
     'j'=>'CYS',
     'k'=>'CYS',
     'l'=>'CYS',
     'm'=>'CYS',
     'n'=>'CYS',
     'o'=>'CYS',
     'p'=>'CYS',
     'q'=>'CYS',
     'r'=>'CYS',
     's'=>'CYS',
     't'=>'CYS',
     'u'=>'CYS',
     'v'=>'CYS',
     'w'=>'CYS',
     'x'=>'CYS',
     'y'=>'CYS',
     'z'=>'CYS',

     'B'=>'ASX',
     'Z'=>'GLX',
     'X'=>'CYS',
    );

@AA=qw(
       C
       M
       F
       I
       L
       V
       W
       Y
       A
       G
       T
       S
       Q
       N
       E
       D
       H
       R
       K
       P
       );

%secondary=(
	    '1'=>'C',
	    '2'=>'H',
	    '4'=>'E',
	    'C'=>'1',
	    'H'=>'2',
	    'E'=>'4',
	    );

################# directories #############################
$data_dir="!DATA_DIR!/!S!";  #for seq.txt and init.dat
$tag="!TAG!";
$usrname="!USER!";
$libdir="!LIB_DIR!";
$o="!O!";
$idcut="!ID_CUT!"; 
$ntemp="!N_TEMP!";
$idcut0=!ID_CUT!;

$libdir_local="$lib";
 $work_dir="/tmp/$usrname/$tag";

################ working directory ########################
`/bin/mkdir -p $work_dir`;
chdir "$work_dir";
`/bin/rm -f $work_dir/*`;

`cp $libdir_local/bin/align ./align`;
 
################ make fasta sequence file #################
@seqtxts=`cat $data_dir/seq.txt`;
$sequence="";
foreach $seqtxt(@seqtxts){
    goto pos6 if($seqtxt=~/\>/);
    $seqtxt=~s/\s//mg;
    $seqtxt=~s/\n//mg;
    $sequence=$sequence.$seqtxt;
  pos6:;
}
$Lch=length $sequence;
open(seq,">protein.seq");
printf seq ">protein $Lch\n";
for($i=1;$i<=$Lch;$i++){
    $a=substr($sequence,$i-1,1);
    printf seq "$a";
    $seqQ{$i}=$a;   #only for check
    if($i==int($i/60)*60){
	printf seq "\n";
    }
}
printf seq "\n";
close(seq);

########### run SPARKX to search against library  ######################

system("$lib/SPARKX/sparks-x/bin/scan1.sh protein.seq");

if(-s "protein.seq.phipsi"){
    open(a,"protein.seq.phipsi");
    open(ss,">seq.spx.ss");
    open(se,">seq.spx");
    printf ss "$Lch   coil  helix  beta\n\n";
    <a>;
    for($i=1;$i<=$Lch;$i++){
	$line=<a>;
	if($line=~/(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
	    $seq3=$2;
	    $sec3=$3;
	    $p_E=$6;
	    $p_C=$7;
	    $p_H=$8;
	    printf ss "%4d %1s %1s %6.4f %6.4f %6.4f \n",
	    $i,$seq3,$sec3,$p_C,$p_H,$p_E;
	    printf se "%5d   %3s%5d%5d\n",
	    $i,$ts{$seq3},$secondary{$sec3},9;
	    printf "%5d   %3s%5d%5d\n",
	    $i,$ts{$seq3},$secondary{$sec3},9;
	}
    }
    close(a);
    close(ss);
    close(se);
}

#### exclude PDB ####
my @exclude_pdb_list=();
if (-s "$data_dir/exclude_pdb_list" )
{
    system("cp $data_dir/exclude_pdb_list $work_dir/exclude_pdb_list");
    foreach my $line(`cat $work_dir/exclude_pdb_list`)
    {
        push(@exclude_pdb_list,substr($line,0,4));
    }
}


$it=0;
open(init,">init.SPARKX")||die "can not open";
open(IN,"protein.seq.zs12")||die "can not open";
while($line=<IN>){
    chomp($line);
    if($line=~/protein.seq\s+(\w+)\s+(\d+\.\d+)\s+/){
	$template_name=$1;
	$zscore=$2;
	
	`cp $lib/SPARKX/PDB/$template_name $template_name\.pdb`;
	
        if (scalar @exclude_pdb_list)
        {
            $template_pdb_ID=substr($template_name,0,4);
            foreach $exclude_pdb_ID (@exclude_pdb_list)
            {
                if($template_pdb_ID eq $exclude_pdb_ID)
                {
		    system("rm $template_name\.pdb");
                    goto PPP;
                }
            }
        }
	if($idcut0<0.999){
	    $align_rst=`./align protein.seq $template_name\.pdb 2`;
	    if($align_rst=~/Identical length\:\s+(\d+)/){
		$id=$1/$Lch;
		if($id>=$idcut0){
		    `rm $template_name\.pdb`;
		    goto PPP;
		}
	    }
	}
	
	open(ALN,"protein.seq.aln")||die "can not open";
      CCC:	
	while($aln_line=<ALN>){
	    if($aln_line=~/^>/){
		chomp($aln_line);
		$aln_line=~s/^\s+//;
		@m_wds = split(/\s+/,$aln_line);
		$my_template = $m_wds[2];
		if($my_template eq "$template_name"){
		    $query_aln=<ALN>;
		    $template_aln=<ALN>;
		    chomp($query_aln);
		    chomp($template_aln);
		    last CCC;
		}
	    }
	}
	close ALN || die "can not close";
	
	$it++;		
	
	###### end of read the template sequence from PDB ########
	
	SPARKX_model($query_aln,$template_aln,$my_template,$zscore,$flag1);
	
	if($it>($ntemp-1)){ ### more than 20 templates
	    goto it_pos_end;
	}
      PPP:;			
	
########
    }else{
	print "Regular Expression match error\n";
    }
    ## end of if
}       ## end of while
 it_pos_end:;
close IN || die "can not close";
close init || die "can not close init file";

#############################################################################

open(init1,">init1.dat");
printf init1 "%5d %5d (N_temp, Lch)\n",$it,$Lch;
close(init1);

`cat init.SPARKX >> init1.dat`;
`cp  init1.dat $data_dir/init$o\.SPX`;

`cp  seq.spx $data_dir/seq.spx$o`;
`cp  seq.spx.ss $data_dir/seq.spx$o.ss`;

#############################################################################

################# endding procedure ######################
$time=`date`;
printf "ending time: $time";
`sync`;
`sync`;
sleep(1);
`rm -fr $work_dir`;

exit();


##################################  

sub SPARKX_model{
    $sequenceQ = $_[0];
    $sequenceT = $_[1];
    $mtemplate_name= $_[2];
    $score = $_[3];
    $flag  = $_[4];
    
    $start_q_pos = 1;
    $start_t_pos = 1;
    
    $sequenceT=~s/\*//mg;
    $sequenceQ=~s/\*//mg;
    $sequenceT=~s/\s+//g;
    $sequenceQ=~s/\s+//g; 
    
    ####### get sequence identity of the alignment ------>
    $L=length $sequenceQ;
    $L_eq=0;  #number of identical residues
    $L_ali=0; #number of aligned residues
    for($j=1;$j<=$L;$j++){
	$sQ=substr($sequenceQ,$j-1,1);
	$sT=substr($sequenceT,$j-1,1);
	if($sQ ne "-" && $sT ne "-"){
	    $L_ali++;
	    if($sQ eq $sT){
		$L_eq++;
	    }
	}
    }
    $seq_id=$L_eq/($L_ali+.0000001); #seq idendity betwen target & template
    
    open(temppdb,"$mtemplate_name\.pdb")||die "can not open";
    $n=0;
    while($line=<temppdb>){
	$ATOM=substr($line,0,4);
	$atom=substr($line,12,4);
	$atom=~s/\s//mg;
	if( $ATOM eq "ATOM" && $atom eq "CA"){
	    $n++;
	    $seqT{$n}=$ts{substr($line,17,3)}; #only for check
	    $numT{$n}=substr($line,22,4);
	    $x{$n}=substr($line,30,8);
	    $y{$n}=substr($line,38,8);
	    $z{$n}=substr($line,46,8);
	}
    }
    close(temppdb)||die "can not close";
    system("rm $template_name\.pdb");
    
    ########## write alignment to 'init.dat' ------------------>
    $a=substr($template_name,0,4);
    if(length $template_name == 4){
	$b="_";
    }else{
	$b=substr($template_name,4,1);
	$b=~tr/a-z/A-Z/;
    }
    
    $temp_name="$a$b";
    $template_name=~s/\\\./\./mg;
    $zscore_value=1;
    printf init "%5d %8.3f %5d   %6s %8.3f %8.3f(=$L_ali/$Lch) (L_ali,Z-score,i,pdb,id,cov)\n",	
    $L_ali,$score,$it,$template_name,$seq_id,$L_ali/$Lch;
    
    $iQ=0;
    $iT=0;
    for($j=1;$j<=length($sequenceQ);$j++){
	$sQ=substr($sequenceQ,$j-1,1);
	$sT=substr($sequenceT,$j-1,1);
	
	if($sQ eq "-"){
	    $iT++;
	}
	
	if($sT eq "-"){
	    $iQ++;
	}		
	
	if($sQ ne "-" && $sT ne "-"){		
	    $iQ++;
	    $iT++;
	    
	    printf init "ATOM  %5s  CA  %3s  %4d    %8.3f%8.3f%8.3f%5s %3s\n",
	    $iQ,$ts{$sQ},$iQ+$start_q_pos-1,$x{$iT+$start_t_pos-1},$y{$iT+$start_t_pos-1},$z{$iT+$start_t_pos-1},$numT{$iT+$start_t_pos-1},$ts{$sT};
	    
	    if($sQ ne $seqQ{$iQ+$start_q_pos-1} || $sT ne $seqT{$iT+$start_t_pos-1}){
		print "$temp_name : $iQ - $sQ = $seqQ{$iQ+$start_q_pos-1} <> $iT - $sT = $seqT{$iT+$start_t_pos-1}\n";
	    }
	    
	}
    }
    printf init "TER\n";
    
  end_pos:;	
}
