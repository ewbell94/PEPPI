#!/usr/bin/perl
#PBS -e !ERRFILE!
#PBS -o !OUTFILE!
#PBS -l !WALLTIME!
#PBS -l !NODE!

# this program is modified from /home/yzhang/bin/cluster/clustermod_Y

$switch="simple"; #1, one model. 2, skip spicker
$switch="full";   #1, complete run

use Math::Trig;

########################################
# please read: http://salilab.org/modeller/manual
# Options:
# 1, use my initial
# 2, use my restraints: http://salilab.org/modeller/manual/node25.html
# 3, add my restraints: http://salilab.org/modeller/manual/node27.html
# 4, loop modeling
########################################

$home="/nfs/amino-home/zhng";
$lib="/nfs/amino-library";


$ENV{'PATH'}='/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/usr/pgi/linux86/bin';
$ENV{'LD_LIBRARY_PATH'}='/usr/local/lib:/usr/lib:/lib';

%ts=(
     'GLY'=>'G',
     'ALA'=>'A',
     'VAL'=>'V',
     'LEU'=>'L',
     'ILE'=>'I',
     'SER'=>'S',
     'THR'=>'T',
     'CYS'=>'C',
     'MET'=>'M',
     'PRO'=>'P',
     'ASP'=>'D',
     'ASN'=>'N',
     'GLU'=>'E',
     'GLN'=>'Q',
     'LYS'=>'K',
     'ARG'=>'R',
     'HIS'=>'H',
     'PHE'=>'F',
     'TYR'=>'Y',
     'TRP'=>'W',

     'ASX'=>'B',
     'GLX'=>'Z',
     'UNK'=>'X',

     'G'=>'GLY',
     'A'=>'ALA',
     'V'=>'VAL',
     'L'=>'LEU',
     'I'=>'ILE',
     'S'=>'SER',
     'T'=>'THR',
     'C'=>'CYS',
     'M'=>'MET',
     'P'=>'PRO',
     'D'=>'ASP',
     'N'=>'ASN',
     'E'=>'GLU',
     'Q'=>'GLN',
     'K'=>'LYS',
     'R'=>'ARG',
     'H'=>'HIS',
     'F'=>'PHE',
     'Y'=>'TYR',
     'W'=>'TRP',

     'a'=>'CYS',
     'b'=>'CYS',
     'c'=>'CYS',
     'd'=>'CYS',
     'e'=>'CYS',
     'f'=>'CYS',
     'g'=>'CYS',
     'h'=>'CYS',
     'i'=>'CYS',
     'j'=>'CYS',
     'k'=>'CYS',
     'l'=>'CYS',
     'm'=>'CYS',
     'n'=>'CYS',
     'o'=>'CYS',
     'p'=>'CYS',
     'q'=>'CYS',
     'r'=>'CYS',
     's'=>'CYS',
     't'=>'CYS',
     'u'=>'CYS',
     'v'=>'CYS',
     'w'=>'CYS',
     'x'=>'CYS',
     'y'=>'CYS',
     'z'=>'CYS',

     'B'=>'ASX',
     'Z'=>'GLX',
     'X'=>'CYS',
     );

%csec=(
       'H'=>'2',   #alpha helix
       'G'=>'2',   #3-helix (3/10 helix)
       'I'=>'2',   #5-helix (pi helix)

       'E'=>'4',   #extended strand, participates in beta ladder
       
       'B'=>'1',   #residue in isolated beta-bridge
       'T'=>'1',   #hydrogen bonded turn
       'S'=>'1',   #bend
       'C'=>'1',
       ' '=>'1',
       );

################## presetting ##########################
$o="!O!";
$s="!S!";
$tag="!TAG!"; 
$user="!USER!";
$tra_dir="!TRADIR!"; # rep1.tra1A
$cluster_dir="!CLUSTERDIR!"; # $home/protein9/54a/cluster
$bindir="!BINDIR!"; # checkCA.pl, mkdat.pl
$commondir="$lib/common"; # *.comm
$dat_dir=$tra_dir; # CA, rmsinp, seq.txt, exp.dat, pair1.dat

############ make /tmp/yzhang ###########################
$work_dir="/tmp/$user/$tag";
`/bin/mkdir -p $work_dir`;
chdir "$work_dir";
`/bin/rm -fr $work_dir/*`;
$stick_dir="/tmp/$user/$tag/mk_stick";
`/bin/mkdir -p $stick_dir`;

######## report node ###################################
`hostname`=~/(\S+)/;
$node=$1;
$time=`date`;
chop($time);
$pwd=`pwd`;
chop($pwd);
print "hostname: $node\n";
print "starting time: $time\n";
printf "pwd: $pwd\n";
system("echo hostname: \"$node\" > $cluster_dir/$s/node");
system("echo starting time: \"$time\" >> $cluster_dir/$s/node");
system("echo pwd: \"$pwd\" >> $cluster_dir/$s/node");
`cp $cluster_dir/$s/node ./node_$tag`;

############# copy cluster files to current directory ##########
### for spicker --->
`/bin/cp $cluster_dir/$s/tra.in .`;
`/bin/cp $dat_dir/CA .`;
`/bin/cp $dat_dir/pdb.pdb .`;
`/bin/cp $dat_dir/rmsinp .`;
if(-s "$dat_dir/seq.com" >5){
    `/bin/cp $dat_dir/seq.com ./seq.dat`;
}else{
    `/bin/cp $dat_dir/seq.dat .`;
}
`/bin/cp $bindir/!SPICKER! ./spicker_$s`;
`/bin/cp $dat_dir/init$o.dat ./init.dat`; #for $type & model.pdb
### for modeller---->
`/bin/cp $bindir/pulchra.pl ./pulchra.pl`;
`/bin/cp $bindir/maxsprout.pl ./maxsprout.pl`;
`/bin/cp $bindir/checkCA.pl .`;
`/bin/cp $bindir/TMscore ./TMscore_local`;
`/bin/cp $bindir/rmsdbin5 ./rmsdbin5_local`;
`/bin/cp $bindir/initQ.pl .`;
`/bin/cp $bindir/initT.pl .`;
`/bin/cp $bindir/hb.pl ./hb.pl`;
`/bin/cp $bindir/mk_restraint.pl ./`;
`/bin/cp $bindir/mktra.pl ./mktra.pl`;
`/bin/cp $bindir/refinement.pl .`;
### for distCA.rsr------->
`/bin/cp $dat_dir/comb$o.dat ./comb.dat`;
`/bin/cp $dat_dir/dist$o.dat ./dist.dat`;
`/bin/cp $dat_dir/combCA$o.dat ./combCA.dat`;
`/bin/cp $dat_dir/distL$o.dat ./distL.dat`;
### for stick------->
`/bin/cp $dat_dir/rmsinp $stick_dir`;
`/bin/cp $dat_dir/seq.dat $stick_dir`;
`/bin/cp $dat_dir/exp.dat $stick_dir`;
`/bin/cp $dat_dir/pair1.dat $stick_dir`;
`/bin/cp $dat_dir/pair3.dat $stick_dir`;
`/bin/cp $bindir/cas_stick1 $stick_dir/cas_stick`;
`/bin/cp $bindir/mkdat12.pl $stick_dir/mkdat.pl`;
`/bin/cp $commondir/* $stick_dir`;

if(!-s "CA"){
    if(-s "pdb.pdb"){
	system("cat pdb.pdb |grep CA > CA");
    }
}

$mix="!MIX!";
if($mix eq "yes"){
    $dd="!DD!";
    $rate_ros="!RATEROS!";
    system("./mktra.pl $s $dd $rate_ros");
    goto pos_t;
}

goto poss1 if($switch eq "simple");
############# copy and unzip trajectories ######################
open(tra,"tra.in");
<tra>=~/(\d+)/;
$n_tra=$1;
for($i=1;$i<=$n_tra;$i++){
    $line=<tra>;
    if($line=~/(\S+)/){
	$traj{$i}=$1;
	if(-s "$tra_dir/$traj{$i}\.bz2"){
	    `/bin/cp $tra_dir/$traj{$i}\.bz2 .`;
	    `/usr/bin/bunzip2 -f $traj{$i}\.bz2`;
	}else{
	    `/bin/cp $tra_dir/$traj{$i} .`;
	}
    }
}
close(tra);

############# re-build 'tra.in' file ######################
# N_PARA=1, for TASSER; N_PARA=-1, for ROS
# N_CLOSC=1, closc from all decoys; N_CLOSC=-1, closc from clustered decoys
$n_tra_new=0;
for($i=1;$i<=$n_tra;$i++){
    if(-s "$traj{$i}"){
	$n_tra_new++;
	$traj_new{$n_tra_new}=$traj{$i};
    }
}
open(train,">tra.in");
print train "$n_tra_new !N_PARA!  !N_CLOSC!\n";
for($i=1;$i<=$n_tra_new;$i++){
    print train "$traj_new{$i}\n";
}
close(train);
 poss1:;

 pos_t:;
############# Cut the residues ######################
$n_cut=!N_CUT!;
if($n_cut>0){
    open(tra,"tra.in");
    <tra>=~/(\d+)/;
    $n_tra=$1;
    for($i=1;$i<=$n_tra;$i++){
	$line=<tra>;
	if($line=~/(\S+)/){
	    $traj=$1;
	    open(tra1,"$traj");
	    open(tra2,">tmp.tra");
	    $m=0;
	    while($line=<tra1>){
		if($line=~/(\S+)/){
		    $N=$1;
		    $m++;
		    print tra2 "$line";
		    for($j=1;$j<=$N;$j++){
			$line=<tra1>;
			print tra2 "$line";
		    }
		    goto pos20 if($m>=$n_cut);
		}
	    }
	  pos20:;
	    close(tra1);
	    close(tra2);
	    sleep(1);
	    `mv tmp.tra $traj`;
	}
    }
    close(tra);
}

if($switch eq "simple"){
    #### copy combo.pdb from former runs =========================>
    $dir_old="$home/protein9/99c1/cluster460c/$s"; #include multi_closc/new_stick
    `cp $dir_old/* .`;
    `rm *model*.pdb`;
    $nc5=1;
    $rst=`$home/bin/modelQ.pl closc$i.pdb combo$i.pdb`; #only output 1 or 2
    if($rst=~/modelq=\s*(\S+)/){ #loose cut for server
    #if($rst=~/modelr=\s*(\S+)/){ #real TM-score, 6 out of 240
	$modelq{1}=$1;
    }
    `echo modelq_$nc5=$modelq{1} >> $cluster_dir/$s/modelq.txt`;
    #$modelq{1}=1;
    goto pos50a;
}

############ run spicker #######################################
system("./spicker_$s");
#^^^^^^^^^^^^^^^^^^^ SPICKER finished ^^^^^^^^^^^^^^^^^^^^^^^^^^

####### nc5 ###############
open(rst,"rst.dat");
while($line=<rst>){
    if($line=~/Number of clusters:\s*(\d+)/){
	$nc=$1;
    }
}
close(rst);
$nc5=!NC5!;
#$nc5=10;
$nc5=$nc if($nc5>$nc);
#$nc5=1;

######## decide runs ------------->
#modelq=1, good model, maxmized TM/GDT/GB, from clustermod257
#modelq=2, bad model, maxmized TM/GDT/GB/SS, from closc from clustermod256
#modelq=3, verybad model, maxmized SS, closc+pulchar+1modeller, clustermod252
#modelq=4, extreme case, maxmized SS, closc+pulchar, clustermod251
#
# In general, the lower the modelq is, the higher TM/GDT/HB score will be; but
# it will also result in model of worse secondary structure for some hard 
# proteins. For easy target, modelq=1 will result in the best TM/GDT/HB/SS.
# modelQ.pl will automatically decide the best modelq (output=1 or 2) which are 
# good for most targets. But for some extremely targets, you can manually change
# modelq to 3 or 4 if you are not satisfied with the look of the final model.
#
for($i=1;$i<=$nc5;$i++){
    $modelq{$i}=1;
    if(-s "closc$i.pdb" && -s "combo$i.pdb"){
	$rst=`$home/bin/modelQ.pl closc$i.pdb combo$i.pdb`; #only output 1 or 2
	#if($rst=~/modelq=\s*(\S+)/){ #looser cut, for server
	if($rst=~/modelr=\s*(\S+)/){ #real TM-score, 6 out of 240
	    $modelq{$i}=$1;
	}
    }
    #$modelq{$i}=2;
}

########################################
# step=1, only 'combo*.pdb' + 'closc*.pdb'
# step=2, 'combo*.pdb' + 'closc*.pdb' + 'stick*.pdb' + 'mod_stick.pdb'
$step=!STEP!; 
goto pos1 if($step<=1); # SPICKER only
##########################################################
################### for stick*.pdb #######################
##########################################################
$type="hard";
if(-s "init.dat"){
    open(a,"init.dat");
    $line=<a>;
    if($line=~/\S+\s+(\S+)/){
	$type=$1;
    }
    close(a);
}
$abs="!ABS!";
if($abs eq "yes"){ #do not need to regenerate stick
    for($i=1;$i<=$nc5;$i++){
	`cp closc$i\.pdb stick$i\.pdb`;
    }
    
    ########### read seq.dat for init ##############
    open(seqdat,"seq.dat");
    $i=0;
    while($line=<seqdat>){
	if($line=~/(\S+)\s+(\S+)/){
	    $i++;
	    $seq10{$i}=$2;
	}
    }
    close(seqdat);
    
    ############ make init.dat for modeller ############
    $n=0;
    for($i=1;$i<=10;$i++){
	$com="!COMBO!$i.pdb";
	if(-s "$com"){
	    $n++;
	    open(com,"$com");
	    while($line=<com>){
		if(substr($line,12,4)=~/CA/){
		    $aL_ali{$n}++;
		    $xyz{$n,$aL_ali{$n}}=substr($line,30,24);
		}
	    }
	    close(com);
	}
    }
    open(init,">init.dat");
    printf init "$n $type\n";
    for($i=1;$i<=$n;$i++){
	printf init "%5d %8.3f %5d   %6s  TAS\n",$aL_ali{$i},-100.0,$i,"unknown";
	for($j=1;$j<=$aL_ali{$i};$j++){
	    printf init "ATOM  %5s  CA  %3s  %4d    %24s\n",
	    $j,$seq10{$j},$j,$xyz{$i,$j};
	}
	printf init "TER\n";
    }
    close(init);
    goto pos50a;
}
chdir "$stick_dir";
##### make 'in.dd' ---------->
$indd="
3
12345        10        10     40     1   40   1.0
0.48    0.1     0.1     0.05    0.05    0.04    0.04    0.08    0.06
80      1.7     23      18      18      6       2.5
1.0     0.2     5       3
1       1       3
 4.1025 48      0.45    0.1     0       5
 4.6538 50      0.25    0.4     0.35    20
 8.0122 4.1010  0.01    2.011
 1.8252 9.925
 0.6314 3.0197  1.3309  1.013   2.1750
 1.5078 1.7847  0.6052
 0.6143 0.6014  0.1
 1
2000 6
7 0.5
12
1       60.0    1   60.0
2
";
open(in,">in.dd");
printf in "$indd\n";
close(in);
for($i=1;$i<=$nc5;$i++){
    if(-s "$work_dir/combo$i\.pdb" && $modelq{$i} ==1){
	`cp $work_dir/combo$i\.pdb .`;
	##### make 'comb.dat' ----->
	system("./mkdat.pl combo$i\.pdb"); # generate init.dat at mk_stick
	##### run 'cas_stick' ------------>
	system("./cas_stick");
	`mv stick.pdb stick$i\.pdb`;
	`cp stick$i\.pdb $work_dir`;
	`mv out.d out$i\.d`;
	`cp out$i\.d $work_dir`;
    }
}
chdir "$work_dir";
#^^^^^^^^ stick*.pdb finished ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

######## check closc.pdb ----------------------------->
for($i=1;$i<=$nc5;$i++){
    if($modelq{$i} == 1){
	`./TMscore_local stick$i\.pdb combo$i\.pdb`=~/RMSD of  the common residues=\s*(\S+)/;
	$rmsd1=$1;
	`./TMscore_local closc$i\.pdb combo$i\.pdb`=~/RMSD of  the common residues=\s*(\S+)/;
	$rmsd2=$1;
	if($rmsd2<=$rmsd1){
	    printf "$i  $rmsd2<$rmsd1, use closc rather than stick\n";
	    `cp closc$i\.pdb stick$i\.pdb`;
	}
    }
}

 pos50a:;
########## convert seq.dat into seq.txt ----------------->
open(seqdat,"seq.dat");
open(seqtxt,">seq.txt");
$i=0;
while($line=<seqdat>){
    if($line=~/(\S+)\s+(\S+)\s+(\S+)/){
	$i++;
	$seq0{$i}=$2;
	$sec1{$i}=$3;
	printf seqtxt "$ts{$2}";
	if(int($i/60)*60==$i){
	    printf seqtxt "\n";
	}
    }
}
$Lch=$i;
printf seqtxt "\n";
close(seqtxt);
close(seqdat);

########### decide class ------------>
$na=0;
$nb=0;
for($i=1;$i<=$Lch;$i++){
    if($sec1{$i} eq "2"){
	$na++;
    }
    if($sec1{$i} eq "4"){
	$nb++;
    }
}
if($na<=10 && $nb>=11){
    $class="b";
}elsif($na>=11 && $nb<=5){
    $class="a";
}elsif($na>=11 && $nb>=7){
    $class="ab";
}else{
    $class="l";
}

############################################################
# generate 'model*.pdb' from 'stick.pdb' ----------------->
$nrun=$nc5;
#$nrun=1;
for($ii=1;$ii<=$nrun;$ii++){
    if($modelq{$ii}==4){
	if(-s "closc$ii.pdb"){
	    `./pulchra.pl closc$ii.pdb`;
	    `cp pul_closc$ii.pdb close$ii\.pdb_pul.pdb`;
	    `cp pul_closc$ii.pdb model$ii\.pdb`;
	    &scwrl("model$ii\.pdb"); #input: $model; output: $model
	}else{
	    printf "warning: without closc$ii.pdb\n";
	}
    }else{
	&getModel("init.dat",$ii,$modelq{$ii});
    }
}

for($i=1;$i<=10;$i++){
    if(-s "model$i.pdb"){
	system("./refinement.pl model$i.pdb REF_model$i.pdb");
    }
}

pos1:;

#################### output TMscore ############################
if(-s "CA"){
    @MM=qw(
	   combo
	   closc
	   stick
	   model
	   REF_model
	   );
    for($i=1;$i<=$nc5;$i++){
	foreach $M(@MM){
	    $model="$M$i\.pdb";
	    $CA="CA";
	    $rmsd{$M,$i}=1000;
	    $TM{$M,$i}=0;
	    $GH{$M,$i}=0;
	    if(-s "$model"){
		$rst=`./TMscore_local $model $CA`;
		if($rst=~/RMSD of  the common residues=\s*(\S+)/){
		    $rmsd{$M,$i}=$1;
		}
		if($rst=~/TM-score    =\s*(\S+)/){
		    $TM{$M,$i}=$1;
		}
		if($rst=~/GDT-HA-score=\s*(\S+)/){
		    $GH{$M,$i}=$1;
		}
	    }
	}
    }
    open(score,">score");
    printf score "$nc5\n";
    for($i=1;$i<=$nc5;$i++){
	printf score "i=$i\n";
	foreach $M(@MM){
	    printf score "%8.3f %8.4f %8.4f %8s\n",
	    $rmsd{$M,$i},$TM{$M,$i},$GH{$M,$i},$M;
	}
    }
    close(score);
    open(score,">HB");
    printf score "$nc5\n";
    for($i=1;$i<=$nc5;$i++){
	foreach $M(@MM){
	    $model="$M$i\.pdb";
	    $pdb="pdb.pdb";   
	    $rst=`./hb.pl $model $pdb`;
	    if($rst=~/Nh1=\s*(\d+)\s+Nh2=\s*(\d+)\s+Nh_comm=\s*(\d+)/){
		$Nh1=$1;
		$Nh2=$2;
		$Nh_comm=$3;
		printf score "%5d %5d %5d $model\n",$Nh1,$Nh2,$Nh_comm;
	    }
	}
    }
    printf score "NH_model   NH_native   NH_comm\n";
    close(score);
}  ##if CA

##################### output 'quality' -------------------------------->
open(rst,"rst.dat");
while($line=<rst>){
    $ntot=$1 if($line=~/Total number of structures=\s*(\d+)/);
    if($line=~/B----/){
	for($i=1;$i<=$nc5;$i++){
	    <rst>=~/(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/;
	    $nstr{$i}=$2;
	    $R_cl_co{$i}=$5;
	}
    }
}
close(rst);
open(dist,">quality");
printf dist " i  nstr_all   nstr(i) R_cl_co R_st_co  icycle0 irep0\n";
for($i=1;$i<=$nc5;$i++){
    if(-s "combo$i\.pdb"){
	open(out,"out$i\.d");
	while($line=<out>){
	    $R_st_co=$1 if($line=~/rmsd_min0=\s*(\S+)/);
	    $icycle0=$1 if($line=~/icycle0=\s*(\S+)/);
	    $irep0=$1 if($line=~/itemp0=\s*(\S+)/);
	}
	printf dist "%5d %5d %5d %8.3f %8.3f %5d %5d\n",
	$i,$ntot,$nstr{$i},$R_cl_co{$i},$R_st_co,$icycle0,$irep0;
    }
}
printf dist "\n       model   R_mo_co --- n19   n36    m19    m36 --- <dis>   ---dis_min---      ---dis_max---\n";
for($i=1;$i<=$nc5;$i++){
    if(-s "model$i\.pdb"){
	`./TMscore_local model$i\.pdb combo$i\.pdb`=~/RMSD of  the common residues=\s*(\S+)/;
	$R_mo_co=$1;
	$rst=`./checkCA.pl model$i\.pdb`;
	$n19=$1 if($rst=~/(\d+)\s+aaa/);
	$n36=$1 if($rst=~/(\d+)\s+bbb/);
	$m19=$1 if($rst=~/(\d+)\s+ccc/);
	$m36=$1 if($rst=~/(\d+)\s+ddd/);
	$disa=$1 if($rst=~/<dis>=\s+(\S+)/);
	$dis_min=$1 if($rst=~/dis_min=\s+(.+)/);
	$dis_max=$1 if($rst=~/dis_max=\s+(.+)/);
	
	printf dist "model$i\.pdb %8.3f --- %5d %5d %5d %5d -- %8.3f  %15s  %15s\n",
	$R_mo_co,
	$n19,$n36,$m19,$m36,
	$disa,$dis_min,$dis_max;
    }
}
close(dist);

##################################################
####### add B-factor to the models ###############
##################################################
# generate B-factor data-------->
`cp $bindir/get_bfactor_new.pl ./get_bfactor.pl`;
system("./get_bfactor.pl $work_dir");
`cp RC_*.dat $cluster_dir/$s`;
for($i=1;$i<=$nc5;$i++){
    if(-s "RC_$i.dat"){
	open(a,"RC_$i.dat");
	while($line=<a>){
	    if($line=~/(\S+)\s+(\S+)/){
		$Bf{$i,$1}=$2;
	    }
	}
	close(a);
    }
}
# add B-factor to models -------->
@MM=qw(
       combo
       closc
       stick
       model
       REF_model
       );
foreach $M(@MM){
    for($i=1;$i<=$nc5;$i++){
	$model="$M$i.pdb";
	if(-s "$model"){
	    `mv $model $model\_tmp`;
	    open(a,"$model\_tmp");
	    open(b,">$model");
	    while($line=<a>){
		if($line=~/^ATOM/){
		    $tmp=substr($line,0,54);
		    if(substr($line,22,4)=~/(\d+)/){
			$res=$1;
		    }
		    printf b "$tmp%6.2f%6.2f\n",1,$Bf{$i,$res};
		}
	    }
	    close(a);
	    close(b);
	}
    }
}
# ^^^^^^^^^^^^^^ B-factor is done ^^^^^^^^^^^^^^^^^^^^^

##########################################
# sometime the disk may fail but the results are still generated at $HOME
# Here we check whether the output are at $work_dir ------->
$output_file="$work_dir/rst.dat";
if(!-s "$output_file"){
    exit();
}

##################################################
# below is for cscore
##################################################
$init="init.dat";
$rst="rst.dat";
$tmp=`$bindir/get_cscore.pl $init $rst`;
open(cscore,">cscore");
print cscore "$tmp\n";
close(cscore);
#^^^^^^^^^^^ model evaluation is done ^^^^^^^^^^^^

########### copy the cluster results back ###############
`/bin/mkdir -p $cluster_dir/$s`;
`rm -f $cluster_dir/$s/*.pdb`;
`/bin/cp ./CA  $cluster_dir/$s`;
`/bin/cp ./pdb.pdb  $cluster_dir/$s`;
`/bin/cp ./*stick*.pdb  $cluster_dir/$s`;
#`/bin/cp ./pul_stick*.pdb  $cluster_dir/$s`;
#`/bin/cp ./*closc*.pdb  $cluster_dir/$s`;
`/bin/cp ./closc?.pdb  $cluster_dir/$s`;
`/bin/cp ./closc??.pdb  $cluster_dir/$s`;
#`/bin/cp ./closc*pul.pdb  $cluster_dir/$s`;
`/bin/cp ./*combo*.pdb  $cluster_dir/$s`;
`/bin/cp ./model*.pdb  $cluster_dir/$s`;
`/bin/cp ./REF*model*.pdb  $cluster_dir/$s`;
`/bin/cp ./cscore   $cluster_dir/$s`;
`/bin/cp ./init.dat  $cluster_dir/$s`;
`/bin/cp ./out*.d  $cluster_dir/$s`;
`/bin/cp ./quality  $cluster_dir/$s`;
`/bin/cp ./HB*  $cluster_dir/$s`;
`/bin/cp ./distCA.rsr  $cluster_dir/$s`;
`/bin/cp ./yzhang.py  $cluster_dir/$s`;
`/bin/cp ./sheet.hb  $cluster_dir/$s`;
`/bin/cp ./seq.dat  $cluster_dir/$s`;
`/bin/cp ./initT.dat  $cluster_dir/$s`;
`/bin/cp ./alignment.ali  $cluster_dir/$s`;
### spicker:
`/bin/cp ./rst.dat  $cluster_dir/$s`;
`/bin/cp ./score   $cluster_dir/$s`;
`/bin/cp ./str.txt  $cluster_dir/$s`;
`/bin/cp ./RMSD.list  $cluster_dir/$s`;

############## remove the directory ################
sleep(1);
`/bin/rm -fr $work_dir`;

exit();

######## remove non-ATOM lines ------------------->
sub cutatom{
    my($file)=@_;
    if(-s "$file"){
	open(old,"$file");
	open(new,">_tmp_");
	while($line=<old>){
	    if($line=~/^ATOM/){
		print new "$line";
	    }
	}
	print new "TER\n";
	close(new);
	close(old);
	`mv _tmp_ $file`;
    }
}

#################################################
## input:  $init, $combo, $stick 
## output: $model
## needed files: pulchra.pl, modeller, checkCA.pl, init_alignT.pl, seq.txt 
##
sub getModel{
    my($init,$ii,$mq)=@_;
    $combo="combo$ii\.pdb"; #used for modeller in the first round, for sec as well
    $stick="stick$ii\.pdb"; #used for modeller in the first round, for sec as well
    $closc="closc$ii\.pdb"; #only for secondary structure
    $model="model$ii\.pdb"; #output

    if($mq!~/\S+/){
	printf "modelq not defined, quit\n";
	return();
    }
    
    if(!-s "$init"){
	printf "without $init, quit\n";
	return();
    }
    if(!-s "$combo"){
	printf "without $init, quit\n";
	return();
    }
    if($mq == 1){
	if(!-s "$stick"){
	    printf "without $init, quit\n";
	    return();
	}
    }
    open(init,"$init");
    <init>=~/(\S+)\s+(\S+)/;
    $type=$2;
    close(init);
    
    #### H-bond parameters ---------->
    $hbw="2.5";
    
    if($mq==1){
	$turn_max=3; #maximum number of iteration
    }elsif($mq==2){
	$turn_max=4; #maximum number of iteration
	if($Lch>400){
	    $turn_max=3; #maximum number of iteration
	}
    }else{ #mq=3
	$turn_max=1;
    }
    $turn=1;
    undef %N_clash;
    undef %ENG;  #clash
    undef %ENG1; #HB/clash
    `rm -f model_turn*`;
    if($mq == 1){
	`./mk_restraint.pl distCA.rsr $combo 1.0`;
    }
    # needed file: comb.dat,dist.dat,combCA.dat,distL.dat
    $rsr="rsr.append(file='distCA.rsr')";
    
    ###########################
  pos_turn:;
    `rm -f target.B*`;
    `rm -f pdb[0-9]*`;
    `rm -f pul_tmp.pdb`;
    `rm -f initT.dat`;
    $turn1=$turn-1;
    if($turn == 1){
	$fix="fix";
	$ini="\# inifile"; #do not use my initial model
	$init_model="";
	undef @ZZ;
	$NTOP=0;
	if($mq ==1){
	    `cp $stick tmp.pdb`; #########stick
	    `./maxsprout.pl tmp.pdb pul_tmp.pdb`;
	    `cp pul_tmp.pdb $stick\_pul.pdb`;
	    `cp $combo tmp.pdb`;  #########combo
	    `./maxsprout.pl tmp.pdb pul_tmp.pdb`;
	    `cp pul_tmp.pdb $combo\_pul.pdb`;
	    `cp $closc tmp.pdb`;  #########closc
	    `./maxsprout.pl tmp.pdb pul_tmp.pdb`;
	    `cp pul_tmp.pdb $closc\_pul.pdb`;
	    $m1="$stick\_pul.pdb";
	    $m2="$combo";
	    $m3="$closc\_pul.pdb";
	    
	    $NTOP++;
	    push(@ZZ,$combo);
	    $NTOP++;
	    push(@ZZ,$stick);
	}else{
	    `cp $combo tmp.pdb`;  #########combo
	    `./pulchra.pl tmp.pdb`;
	    `cp pul_tmp.pdb $combo\_pul.pdb`;
	    `cp $closc tmp.pdb`;  #########closc
	    `./pulchra.pl tmp.pdb`;
	    `cp pul_tmp.pdb $closc\_pul.pdb`;
	    $m1="$closc\_pul.pdb";
	    $m2="$combo";
	    $m3="$closc\_pul.pdb";
	    
	}
	### add multiple closc to initT.dat ------->
	if($mq==1){
	    if($type eq "easy" || $type eq "medm"){
		$n_cl=0;
	    }else{
		$n_cl=36;
	    }
	}else{
	    if($type eq "easy" || $type eq "medm"){
		$n_cl=50;
	    }else{
		$n_cl=6;
	    }
	}
	for($i=1;$i<=$n_cl;$i++){
	    $closci{$i}="closc$ii\_$i.pdb";
	    if(-s "$closci{$i}"){
		`cp $closci{$i} tmp.pdb`;  #########closc
		`./pulchra.pl tmp.pdb`;
		`cp pul_tmp.pdb $closci{$i}\_pul.pdb`;
		
		$NTOP++;
		push(@ZZ,$closci{$i});
	    }
	}
	$RES=getRES($m1,$m2,$m3); #get H-bond list, from $m1,$m2,$m3
    }else{
	$fix="";
	$ini="\# inifile"; #do not use my initial model
	#$ini="inifile"; # use my initial models
	$init_model="model_turn$turn1\.pdb";
	undef @ZZ;
	$NTOP=0;
	if($mq ==1){
	    if($turn<=$turn_max/2){
		push(@ZZ,$combo);
		$NTOP++;
	    }
	    push(@ZZ,$stick);
	    $NTOP++;
	    for($i=1;$i<=$turn;$i++){
		$i1=$i-1;
		push(@ZZ,"model_turn$i1\.pdb");
		$NTOP++;
	    }
	}else{
	    for($i=$turn;$i<=$turn;$i++){
		$i1=$i-1;
		push(@ZZ,"model_turn$i1\.pdb");
		$NTOP++;
	    }
	}
	###
	$m1="$init_model";
	$m2="$combo";
	$m3="$init_model";
	$RES=getRES($m1,$m2,$m3);
    }
    $NTOP+=14 if($mq ==1);
    if($class eq "a"){ #do not sort template
	$NTOP+=8;
    }else{ #b,ab,l, sort template
	if($type eq "easy"){
	    $NTOP+=5;    # for init.dat
	    $TM_cut=0.3;
	}elsif($type eq "medm"){
	    $NTOP+=6;    # for init.dat
	    $TM_cut=0.5;
	}else{
	    $NTOP+=5;    # for init.dat
	    $TM_cut=0.35;
	}
    }
    if($mq >1){
	$tmp="model_turn$turn1\.pdb";
	if(!-s "$tmp"){
	    $tmp="$closc\_pul.pdb";
	}
	`./mk_restraint.pl distCA.rsr $tmp -1.0`;
    }
    
    $k=0;
    ###### make TASSER*.pdb from combo*.pdb and stick*.pdb and read backbone ------->
    foreach $Z(@ZZ){
	if(-s "$Z"){
	    $k++;
	    if($Z!~/model/){
		if(!-s "$Z\_pul.pdb"){
		    `cp $Z tmp.pdb`;
		    if($mq ==1){
			`./maxsprout.pl tmp.pdb pul_tmp.pdb`;
		    }else{
			`./pulchra.pl tmp.pdb $fix`;
		    }
		    `cp pul_tmp.pdb $Z\_pul.pdb`;
		}
		`cp $Z\_pul.pdb TASSER$k\.pdb`;
	    }else{
		`cp $Z TASSER$k\.pdb`;
	    }
	    open(model,"TASSER$k\.pdb");
	    $j=0;
	    while($line=<model>){
		if(substr($line,12,4)=~/CA/){
		    $j++;
		    $LINE{$k,$j}=sprintf("%54s%5d %3s\n",substr($line,0,54),
					 substr($line,22,4),substr($line,17,3));
		}
	    }
	    close(model);
	    $L_ali{$k}=$j;
	    $zscore{$k}=100;
	    $temp{$k}="TASSER$k\.pdb";
	    $ori{$k}="TAS";
	}
    }
    ###### read init.dat (TASSER init) ------->
    open(init,"$init"); #$init=init.dat
    <init>=~/(\S+)\s+(\S+)/;
    $Nt=$1;
    $type=$2;
    for($i=1;$i<=$Nt;$i++){
	$k++;
	<init>=~/(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/;
	$L_ali{$k}=$1;
	$zscore{$k}=$2;
	$temp{$k}=$4;
	$ori{$k}=$5;
	for($j=1;$j<=$L_ali{$k};$j++){
	    $LINE{$k,$j}=<init>;
	}
	if(substr($LINE{$k,1},60,3)!~/[A-Z][A-Z][A-Z]/){
	    ###### convert full-length model into threading format ------>
	    $ori{$k}="TAS";
	    $temp{$k}="TASSER$k\.pdb";
	    open(tas,">$temp{$k}");
	    for($j=1;$j<=$L_ali{$k};$j++){
		print tas "$LINE{$k,$j}";
		$LINE{$k,$j}=sprintf("%54s%5d %3s\n",
				     substr($LINE{$k,$j},0,54),
				     substr($LINE{$k,$j},22,4),
				     substr($LINE{$k,$j},17,3));
	    }
	    close(tas);
	}
	<init>;
    }
    close(init);
    #^^^^^^ reading templates finished ^^^^^^^^^^^^^^^^^
    $NTOP=$k if($NTOP>$k);
    
    ########## prepare 'initT.dat'=combo+init.dat #################
    if($class eq "a"){
	open(init,">initT.dat");
	print init "$k  $type\n";
	$ik=0;
	for($i=1;$i<=$k;$i++){
	    open(tmp,">tmp$i\.pdb");
	    for($j=1;$j<=$L_ali{$i};$j++){
		print tmp "$LINE{$i,$j}";
	    }
	    close(tmp);
	    $rst=`./rmsdbin5_local tmp$i\.pdb $combo`;
	    $rst=~/RMSD=\s*(\S+)/;
	    if($1 > 80.0){
		`rm -f tmp$i\.pdb`;
		goto NKP;
	    }
	    $ik++;
	    printf init "%5d %8.3f %5d %20s %5s\n",
	    $L_ali{$i},$zscore{$i},$ik,$temp{$i},$ori{$i};
	    for($j=1;$j<=$L_ali{$i};$j++){
		print init "$LINE{$i,$j}";
	    }
	    printf init "TER\n";
	    goto pos6a if($ik>=$NTOP);
	  NKP:
	}
      pos6a:;
	close(init);
    }else{
	#1#### re-order templates by TMscore ----------->
	undef %TMs;
	for($i=1;$i<=$k;$i++){
	    open(tmp,">tmp$i\.pdb");
	    for($j=1;$j<=$L_ali{$i};$j++){
		print tmp "$LINE{$i,$j}";
	    }
	    close(tmp);
	    if($mq ==1){
		$rst=`./TMscore_local tmp$i\.pdb $combo`;
	    }else{
		$rst=`./TMscore_local tmp$i\.pdb $closc\_pul.pdb`;
	    }
	    if($rst=~/TM-score    =\s*(\S+)/){
		$TMs{$i}=$1;
	    }
	}
	@TMs_keys=sort{$TMs{$b}<=>$TMs{$a}} keys %TMs;
	#2#### remove redudent ---------->
	$it=0;
	for($i=1;$i<=$k;$i++){
	    $m=$TMs_keys[$i-1];
	    #printf "$m, $TMs{$m}, $TM_cut\n";
	    if($TMs{$m}<=$TM_cut){
		goto pos4;
	    }
	    ##### remove redunt ------>
	    for($l=1;$l<$i;$l++){
		$m1=$TMs_keys[$l-1];
		$rst=`./rmsdbin5_local tmp$m\.pdb tmp$m1\.pdb`;
		$rst=~/Chain 1.+Size=\s*(\d+)/;
		$L1=$1;
		$rst=~/Chain 2.+Size=\s*(\d+)/;
		$L2=$1;
		if($rst=~/RMSD=\s*(\S+)/){
		    $RMSD=$1;
		    if($RMSD<=0.01 && $L1 == $L2){
			goto pos4;
		    }
		}
	    }
	    $it++;
	    $newT{$it}=$m;
	  pos4:;
	    goto pos6 if($it>=$NTOP);
	}
      pos6:;
	#3### output init.dat ----------->
	open(init,">initT.dat");
	print init "$it  $type\n";
	for($i=1;$i<=$it;$i++){
	    $k1=$newT{$i};
	    printf init "%5d %8.3f %5d %20s %5s\n",
	    $L_ali{$k1},$zscore{$k1},$k1,$temp{$k1},$ori{$k1};
	    for($j=1;$j<=$L_ali{$k1};$j++){
		print init "$LINE{$k1,$j}";
	    }
	    printf init "TER\n";
	}
	close(init);
	$NTOP=$it if($NTOP>$it);
    }
    
    ######### run modeller ------------------------>
    for($I=$NTOP;$I>=1;$I--){
	$ntop=$I;
	printf "ii=$ii--turn$turn---$combo ---------$I ---- $ntop -------------\n";
	
	#copy 'pdb*', make 'alignment.ali' --------->
	if($turn<$turn_max){
	    system("./initQ.pl initT.dat seq.txt $ntop"); #pdb_seq from query, CA only
	}else{
	    system("./initT.pl initT.dat seq.txt $ntop"); #pdb_seq from template, have side-chain
	}
	
	#### generate 'yzhang.py' ------------->
	if($mq ==1){
	    $nm=3;
	}else{
	    $nm=4;
	}
	$tmp="";
	for($i=1;$i<=$I;$i++){
	    if(-s "pdb$i"){
		$tmp .="'pdb$i',";
	    }
	}
	$tmp=~/(.+)\,/;
	$known="($1)";
	$top_mod="
from modeller import *
from modeller.automodel import * \# Load the automodel class
log.verbose()                    \# MODELLER to display all log output.
env = environ()                  \# assign new environ object to the Python

\# Give less weight to all soft-sphere restraints:
\# env.schedule_scale = physical.values(default=1.0, soft_sphere=0.7)
env.schedule_scale = physical.values(default=1.0, h_bond=$hbw)

\# directories for input atom files
env.io.atom_files_directory = './:../atom_files'

class mymodel(automodel):
    def special_restraints(self, aln):
        rsr = self.restraints
        at = self.atoms
\#     Add some restraints from a file:
\#      rsr.append(file='distCA.rsr')
        $rsr

$RES
\#       Residues 20 through 30 should be an alpha helix:
\#        rsr.add(secondary_structure.alpha(self.residue_range('20:', '30:')))
\#       Two beta-strands:
\#        rsr.add(secondary_structure.strand(self.residue_range('1:', '6:')))
\#        rsr.add(secondary_structure.strand(self.residue_range('9:', '14:')))
\#       An anti-parallel sheet composed of the two strands:
\#        rsr.add(secondary_structure.sheet(at['N:1'], at['O:14'],sheet_h_bonds=-5))
\#       Use the following instead for a *parallel* sheet:
\#       rsr.add(secondary_structure.sheet(at['N:1'], at['O:9'],sheet_h_bonds=5))
        
\#       Restrain the specified CA-CA distance to 10 angstroms (st. dev.=0.1)
\#       Use a harmonic potential and X-Y distance group.
\#        rsr.add(forms.gaussian(group=physical.xy_distance,feature=features.distance(at['CA:35'],at['CA:40']),mean=10.0, stdev=0.1))

a = mymodel(env, 
              \# file with template codes and target sequence
              alnfile='alignment.ali', 
              \# PDB codes of the templates
              knowns=$known, 
              \# code of the target
              sequence='target',
              \# csrfile  = 'my.rsr'
              \# use 'my' restraints file
              $ini  = '$init_model'
              \# use 'my' initial structure
              \# csrfile  = 'distCA.rsr'
              \# use 'my' restraints file only
              )
a.starting_model = 1              \# index of the first model
a.ending_model = $nm                \# index of the last model
                                  \# determines how many models to calculate
a.make()                          \# do homology modelling
";
	open(top,">yzhang.py");
	print top "$top_mod";
	close(top);
	
	#### run MODELLER ----------------------->
	#`ln -sf $bindir/modeller8v1/bin/mod8v1 ./mo`;
	#`ln -sf $bindir/modeller-8v2/bin/mod8v2 ./mo`;
	#`ln -sf $bindir/modeller9v2/bin/mod9v2 ./mo`;
	#`ln -sf $bindir/modeller9v3/bin/mod9v3 ./mo`;
	#`ln -sf $home$lib/bin/modeller9v4/bin/mod9v4 ./mo`;
	#`ln -sf $lib/bin/modeller9v7/bin/mod9v7 ./mo`;
	#`ln -sf $lib/bin/modeller9v12/bin/mod9.12 ./mo`;
	`ln -sf $lib/bin/modeller9.14/bin/mod9.14 ./mo`;
	`./mo yzhang.py`;
	if(`/bin/ls target.B999900*.pdb`=~/target/){
	    undef %function;
	    for($i=1;$i<=$nm;$i++){
		$tmp="target.B9999000$i\.pdb";
		if(-s "$tmp"){
		    ##### checkCA.pl ------------------->
		    $rst=`./checkCA.pl $tmp`;
		    $N36a=$1 if($rst=~/(\d+)\s+ddd/);
		    ##### hb.pl------------------->
		    $rst=`./hb.pl $tmp $tmp`;
		    if($rst=~/Nh1=\s*(\d+)/){
			$hb=$1;
			$function{$i}=$hb/($N36a+5);
		    }
		}
	    }
	    @function_keys=sort{$function{$b}<=>$function{$a}} keys %function;
	    $k=$function_keys[0];
	    $tmp="target\.B9999000$k\.pdb"; #slightly better than target.B9999000$nm.pdb
	    cutatom("$tmp");
	    
	    `cp $tmp model_turn$turn\.pdb`;
	    goto pos3;
	}else{
	    `echo modeller_failed_at s=$s ii=$ii I=$I turn=$turn ntop=$ntop >> $cluster_dir/$s/err.txt`;
	}
    }
  pos3:;
    #`mkdir dir_$ii\_$turn\_$I`;
    #`cp * dir_$ii\_$turn\_$I`;
    if(!-s "model_turn$turn\.pdb"){
	$a1=$turn-1;
	if(-s "model_turn$a1\.pdb"){
	    `cp model_turn$a1\.pdb model_turn$turn\.pdb`;
	}else{
	    if($mq ==1){
		`cp $stick tmp.pdb`;
	    }else{
		`cp $closc tmp.pdb`;
	    }
	    `./pulchra.pl tmp.pdb`;
	    `cp pul_tmp.pdb model_turn$turn\.pdb`;
	}
    }
    
    ##### checkCA.pl ------------------->
    $rst=`./checkCA.pl model_turn$turn\.pdb`;
    $N36a=$1 if($rst=~/(\d+)\s+ddd/);
    $N_clash{$turn}=$N36a+$turn/10.0;
    $ENG{$turn}=$N_clash{$turn};
    ##### hb.pl------------------->
    $rst=`./hb.pl model_turn$turn\.pdb model_turn$turn\.pdb`;
    if($rst=~/Nh1=\s*(\d+)/){
	$hb=$1;
	$ENG1{$turn}=$hb/($N_clash{$turn}+5);
    }
    printf "turn=$turn, n_clash=$N_clash{$turn}, N19=$N19a, N36=$N36a, N_hb=$hb\n";
    if($turn<$turn_max){
	$turn++;
	goto pos_turn;
    }
    
    ######## output energy and select models --------->
    #@ENG_keys=sort{$ENG{$a}<=>$ENG{$b}} keys %ENG;
    #$k=$ENG_keys[0];
    #`cp model_turn$k\.pdb $model`;
    @ENG1_keys=sort{$ENG1{$b}<=>$ENG1{$a}} keys %ENG1;
    $k=$ENG1_keys[0];
    $k=$turn;
    `cp model_turn$k\.pdb $model`;
    
    ######### run scwr4.0 #################################################
    &scwrl("$model"); #input: $model; output: $model
    
    open(energy,">$model\_energy");
    for($i=1;$i<=$turn;$i++){
	printf energy "%5d %10.3f %10.3f\n",$i,$ENG{$i},$ENG{$i};
    }
    printf energy " i  n_clash   N_HB/n_clash\n";
    close(energy);
}

sub scwrl{
    my($model)=@_;
    `rm -f $model\.scw`;
    ######### run scwr4.0 #################################################
    `$home/bin/exe_time.pl 20 $home/bin/sidechain.pl $model`; #$model\.scw
    if(-s "$model\.scw" >500){
	`mv $model $model\.old`;
	`mv $model\.scw $model`;
    }
}

####################################################
# generate secondary structure restraints
#
sub getRES{
    my($mm1,$mm2,$mm3)=@_;
    #$mm1: for sec2 and N-O distance of beta-sheets
    #$mm2: for CA-CA distance of beta-sheets
    #$mm3: from closc
    
    ###### generate sec2{i} from modeller model----------->
    cutatom("$mm1");
    system("$bindir/stride $mm1 > stride.out 2> /dev/null");
    if(-s "stride.out"){
	open(dsspout,"stride.out");
	$k=0;
	while($line=<dsspout>){
	    if($line=~/REM  \|---Residue---\|/){
		while($line=<dsspout>){
		    $res=substr($line,10,5); #12
		    $res=~s/\s//mg;
		    $seqtmp=substr($line,5,3); #LEU
		    if($seqtmp eq $seq0{$res}){
			$k++;
			$sec2{$res}=$csec{substr($line,24,1)};  #H=>2
			goto pos31 if($k >= $Lch);
		    }else{
			printf "$s $res  $seqtmp ne $seq0{$res} CA  and pdb mismatch\n";
		    }
		}
	    }
	}
      pos31:;
	close(dsspout);
    }
    ###### generate sec3{i} from closc----------->
    cutatom("$mm3");
    system("$bindir/stride $mm3 > stride.out 2> /dev/null");
    if(-s "stride.out"){
	open(dsspout,"stride.out");
	$k=0;
	while($line=<dsspout>){
	    if($line=~/REM  \|---Residue---\|/){
		while($line=<dsspout>){
		    $res=substr($line,10,5); #12
		    $res=~s/\s//mg;
		    $seqtmp=substr($line,5,3); #LEU
		    if($seqtmp eq $seq0{$res}){
			$k++;
			$sec3{$res}=$csec{substr($line,24,1)};  #H=>2
			goto pos31a if($k >= $Lch);
		    }else{
			printf "$s $res  $seqtmp ne $seq0{$res} CA  and pdb mismatch\n";
		    }
		}
	    }
	}
	pos31a:;
	close(dsspout);
    }
    ####### decide $sec{$i}----------------->
    for($i=1;$i<=$Lch;$i++){
	$sec{$i}=1;
	if($sec1{$i} eq "2" && $sec3{$i} eq "2"){ #closc+seq
	    $sec{$i}=2;
	}
	if($sec1{$i} eq "4" || $sec2{$i} eq "4"){ #stick+seq
	    $sec{$i}=4;
	}
	#printf "$i, $sec1{$i}, $sec2{$i}, $sec{$i}\n";
    }
    
    ######## smoothen------------------------->
    ## --x-- ===> -----
    for($i=1;$i<=$Lch;$i++){
	if($sec{$i} ne "1"){
	    if($sec{$i-2} ne $sec{$i}){
	    if($sec{$i-1} ne $sec{$i}){
	    if($sec{$i+1} ne $sec{$i}){
	    if($sec{$i+2} ne $sec{$i}){
		$sec{$i}="1";
	    }
	    }
	    }
	    }
	}
    }
    goto pos50;
    ## --xx-- ===> -----
    for($i=1;$i<=$Lch;$i++){
	if($sec{$i} ne "1" && $sec{$i+1} ne "1" && $sec{$i} eq $sec{$i+1}){
	    if($sec{$i-2} ne $sec{$i}){
	    if($sec{$i-1} ne $sec{$i}){
	    if($sec{$i+2} ne $sec{$i}){
	    if($sec{$i+3} ne $sec{$i}){
		$sec{$i}="1";
		$sec{$i+1}="1";
	    }
	    }
	    }
	    }
	}
    }
    ## x-x ==> xxx
    for($i=1;$i<=$Lch;$i++){
	if($sec{$i} eq "1"){
	    if($sec{$i-1} eq $sec{$i+1} && $sec{$i-1} ne "1"){
		$sec{$i}=$sec{$i-1};
	    }
	}
    }
  pos50:;
    
    ####### decided SS fragments ----------->
    $na=0; #number of helix 
    for($i=1;$i<=$Lch;$i++){
	if($sec{$i} eq "2"){
	    if($sec{$i} ne $sec{$i-1}){
		$na++;
		$nai{$na}=$i;
	    }
	    if($sec{$i} ne $sec{$i+1}){
		$naf{$na}=$i;
	    }
	}
    }
    $nb=0; #number of strands
    for($i=1;$i<=$Lch;$i++){
	if($sec{$i} eq "4"){
	    if($sec{$i} ne $sec{$i-1}){
		$nb++;
		$nbi{$nb}=$i;
	    }
	    if($sec{$i} ne $sec{$i+1}){
		$nbf{$nb}=$i;
	    }
	}
    }
    
    ####################################################
    ######
    ###### identify sheet locations ------------------->
    ######
    $HB_cut=6.1;
    $L_cut=3;
    if($nb>2){
	open(mod,"$mm1"); #for distance of O-N for H-bond in sheet
	while($line=<mod>){
	    if($line=~/^ATOM/){
		substr($line,12,4)=~/(\S+)/;
		$atom=$1;
		substr($line,22,4)=~/(\d+)/;
		$nr=$1;
		substr($line,6,5)=~/(\d+)/;
		$n_atom=$1;
		if($atom eq "N"){
		    $xN{$nr}=substr($line,30,8);
		    $yN{$nr}=substr($line,38,8);
		    $zN{$nr}=substr($line,46,8);
		}
		if($atom eq "O"){
		    $xO{$nr}=substr($line,30,8);
		    $yO{$nr}=substr($line,38,8);
		    $zO{$nr}=substr($line,46,8);
		}
	    }
	}
	close(mod);
	open(combo,"$mm2"); #for judge sheet based on CA-CA
	$L=0;
	while($line=<combo>){
	    if(substr($line,12,4)=~/CA/){
		$L++;
		$xc{$L}=substr($line,30,8);
		$yc{$L}=substr($line,38,8);
		$zc{$L}=substr($line,46,8);
	    }
	}
	close(combo);
	##### decide parallel sheet ------------>
	$M_sheet=0;
	for($i=1;$i<$nb;$i++){ #stand1
	    for($j=$i+1;$j<=$nb;$j++){ #strand2
		$n_sheet=0;
		undef %HL;
		undef %DIS;
		for($i1=$nbi{$i};$i1<=$nbf{$i};$i1++){
		    for($j1=$nbi{$j};$j1<=$nbf{$j};$j1++){
			$L=0;
			$dis_a=0;
		      pos60:;
			$pi=$i1+$L;
			$pj=$j1+$L;
			$mk=-1;
			if($pi>=$nbi{$i} && $pi<=$nbf{$i}){
			    if($pj>=$nbi{$j} && $pj<=$nbf{$j}){
				if(abs($pi-$pj)>=3){
				    $dis=sqrt(($xc{$pi}-$xc{$pj})**2+
					      ($yc{$pi}-$yc{$pj})**2+
					      ($zc{$pi}-$zc{$pj})**2);
				    if($dis<=$HB_cut){
					$mk=1;
				    }
				}
			    }
			}
			if($mk>0){
			    $L++;
			    $dis_a+=$dis;
			    goto pos60;
			}
			$n_sheet++;
			$start{$n_sheet}="$i1 $j1";
			$HL{$n_sheet}=$L;
			$DIS{$n_sheet}=0;
			if($L>0){
			    $DIS{$n_sheet}=$dis_a/$L;
			}
		    }
		}
		@HL_keys=sort{$HL{$b}<=>$HL{$a}} keys %HL;
		$k=$HL_keys[0];
		if($HL{$k}>=$L_cut){
		    for($m=1;$m<=$n_sheet;$m++){ #check same HL but smaller DIS
			if($HL{$m} == $HL{$k}){
			    if($DIS{$m}<=$DIS{$k}){
				$k=$m;
			    }
			}
		    }
		    $M_sheet++;
		    $start{$k}=~/(\d+)\s+(\d+)/;
		    $residue_i{$M_sheet}=$1;
		    $residue_j{$M_sheet}=$2;
		    $L_sheet{$M_sheet}=$HL{$k};
		}
	    }
	}
	##### decide anti-parallel sheet ------------>
	$M_sheetR=0;
	for($i=1;$i<$nb;$i++){ #stand1
	    for($j=$i+1;$j<=$nb;$j++){ #strand2
		$n_sheet=0;
		undef %HL;
		undef %DIS;
		for($i1=$nbi{$i};$i1<=$nbf{$i};$i1++){
		    for($j1=$nbi{$j};$j1<=$nbf{$j};$j1++){
			$L=0;
			$dis_a=0;
		      pos60a:;
			$pi=$i1+$L;
			$pj=$j1-$L;
			$mk=-1;
			if($pi>=$nbi{$i} && $pi<=$nbf{$i}){
			    if($pj>=$nbi{$j} && $pj<=$nbf{$j}){
				if(abs($pi-$pj)>=3){
				    $dis=sqrt(($xc{$pi}-$xc{$pj})**2+
					      ($yc{$pi}-$yc{$pj})**2+
					      ($zc{$pi}-$zc{$pj})**2);
				    if($dis<=$HB_cut){
					$mk=1;
				    }
				}
			    }
			}
			if($mk>0){
			    $L++;
			    $dis_a+=$dis;
			    goto pos60a;
			}
			$n_sheet++;
			$start{$n_sheet}="$i1 $j1";
			$HL{$n_sheet}=$L;
			$DIS{$n_sheet}=0;
			if($L>0){
			    $DIS{$n_sheet}=$dis_a/$L;
			}
		    }
		}
		@HL_keys=sort{$HL{$b}<=>$HL{$a}} keys %HL;
		$k=$HL_keys[0];
		if($HL{$k}>=$L_cut){
		    for($m=1;$m<=$n_sheet;$m++){ #check same HL but smaller DIS
			if($HL{$m} == $HL{$k}){
			    if($DIS{$m}<=$DIS{$k}){
				$k=$m;
			    }
			}
		    }
		    $M_sheetR++;
		    $start{$k}=~/(\d+)\s+(\d+)/;
		    $residueR_i{$M_sheetR}=$1;
		    $residueR_j{$M_sheetR}=$2;
		    $L_sheetR{$M_sheetR}=$HL{$k};
		}
	    }
	}
    }
    
    ########## generate $RES --------------------------->
    $RES="";
    ###### alpha helix ----------->
    for($i=1;$i<=$na;$i++){
	$RES .="        rsr.add(secondary_structure.alpha(self.residue_range('$nai{$i}:', '$naf{$i}:')))\n";
    }
    ###### beta strands ---------->
    for($i=1;$i<=$nb;$i++){
	$RES .="        rsr.add(secondary_structure.strand(self.residue_range('$nbi{$i}:', '$nbf{$i}:')))\n";
    }
    #goto pos80;
    ###### parallel beta sheets (cross) ----------->
    printf "parallel\n";
    open(hh,">sheet.hb");
    for($i=1;$i<=$M_sheet;$i++){
	#printf "B-parallel: $i-->$residue_i{$i}<->$residue_j{$i} L=$L_sheet{$i}\n";
	$L=$L_sheet{$i}-1;
	######### suppose N(i+1)-O(j):
	$n=0;
	$dis1=0;
	for($j=1;$j<=$L;$j++){
	    $k=2*$j-1; #1,3,5
	    $I=$residue_i{$i}+$k;
	    $J1=$residue_j{$i}+$k-1;
	    $J2=$residue_j{$i}+$k+1;
	    $n++;
	    $hall{1,$n}="N:$I-O:$J1";
	    $dis1+=sqrt(($xN{$I}-$xO{$J1})**2+
			($yN{$I}-$yO{$J1})**2+
			($zN{$I}-$zO{$J1})**2);
	    goto pos60b if($n>=$L);
	    $n++;
	    $hall{1,$n}="O:$I-N:$J2";
	    $dis1+=sqrt(($xO{$I}-$xN{$J2})**2+
			($yO{$I}-$yN{$J2})**2+
			($zO{$I}-$zN{$J2})**2);
	    goto pos60b if($n>=$L);
	}
      pos60b:;
	$dis1/=$L;
	######### suppose O(i)-N(j+1):
	$n=0;
	$dis2=0;
	for($j=1;$j<=$L;$j++){
	    $k=2*$j-1; #1,3,5
	    $I1=$residue_i{$i}+$k-1;
	    $I2=$residue_i{$i}+$k+1;
	    $J=$residue_j{$i}+$k;
	    $n++;
	    $hall{2,$n}="O:$I1-N:$J";
	    $dis2+=sqrt(($xO{$I1}-$xN{$J})**2+
			($yO{$I1}-$yN{$J})**2+
			($zO{$I1}-$zN{$J})**2);
	    goto pos61 if($n>=$L);
	    $n++;
	    $hall{2,$n}="N:$I2-O:$J";
	    $dis2+=sqrt(($xN{$I2}-$xO{$J})**2+
			($yN{$I2}-$yO{$J})**2+
			($zN{$I2}-$zO{$J})**2);
	    goto pos61 if($n>=$L);
	}
      pos61:;
	$dis2/=$L;
	if($dis1<$dis2){ ######### suppose N(i+1)-O(j):
	    for($q=1;$q<=$L;$q++){
		printf hh "$hall{1,$q}\n";
	    }
	    $n=$residue_i{$i}+1;
	    $p=$residue_j{$i};
	    $RES .="        rsr.add(secondary_structure.sheet(at['N:$n'], at['O:$p'],sheet_h_bonds=$L))\n";
	}else{           ######### suppose O(i)-N(j+1):
	    for($q=1;$q<=$L;$q++){
		printf hh "$hall{2,$q}\n";
	    }
	    $p=$residue_i{$i};
	    $n=$residue_j{$i}+1;
	    $RES .="        rsr.add(secondary_structure.sheet(at['O:$p'], at['N:$n'],sheet_h_bonds=$L))\n";
	}
    }
    ###### anti-parallel beta sheets (same residues)----------->
    for($i=1;$i<=$M_sheetR;$i++){
	$L=$L_sheetR{$i}-1;
	######### suppose N(i+1)-O(j-1):
	$n=0;
	$dis1=0;
	for($j=1;$j<=$L;$j++){
	    $k=2*$j-1; #1,3,5
	    $I=$residueR_i{$i}+$k;
	    $J=$residueR_j{$i}-$k;
	    $n++;
	    $hall{1,$n}="N:$I-O:$J";
	    $dis1+=sqrt(($xN{$I}-$xO{$J})**2+
			($yN{$I}-$yO{$J})**2+
			($zN{$I}-$zO{$J})**2);
	    goto pos70 if($n>=$L);
	    $n++;
	    $hall{1,$n}="O:$I-N:$J";
	    $dis1+=sqrt(($xO{$I}-$xN{$J})**2+
			($yO{$I}-$yN{$J})**2+
			($zO{$I}-$zN{$J})**2);
	    goto pos70 if($n>=$L);
	}
      pos70:;
	$dis1/=$L;
	######### suppose O(i)-N(j):
	$n=1;
	$I=$residueR_i{$i};
	$J=$residueR_j{$i};
	$hall{2,$n}="O:$I-N:$J";
	$dis2=sqrt(($xO{$I}-$xN{$J})**2+
		   ($yO{$I}-$yN{$J})**2+
		   ($zO{$I}-$zN{$J})**2);
	goto pos71 if($n>=$L);
	for($j=1;$j<=$L;$j++){
	    $k=2*$j; #2,4,6
	    $I=$residueR_i{$i}+$k;
	    $J=$residueR_j{$i}-$k;
	    $n++;
	    $hall{2,$n}="N:$I-O:$J";
	    $dis2+=sqrt(($xN{$I}-$xO{$J})**2+
			($yN{$I}-$yO{$J})**2+
			($zN{$I}-$zO{$J})**2);
	    goto pos71 if($n>=$L);
	    $n++;
	    $hall{2,$n}="O:$I-N:$J";
	    $dis2+=sqrt(($xO{$I}-$xN{$J})**2+
			($yO{$I}-$yN{$J})**2+
			($zO{$I}-$zN{$J})**2);
	    goto pos71 if($n>=$L);
	}
      pos71:;
	$dis2/=$L;
	if($dis1<$dis2){ ######### suppose N(i+1)-O(j-1):
	    for($q=1;$q<=$L;$q++){
		printf hh "$hall{1,$q}\n";
	    }
	    $n=$residueR_i{$i}+1;
	    $p=$residueR_j{$i}-1;
	    $RES .="        rsr.add(secondary_structure.sheet(at['N:$n'], at['O:$p'],sheet_h_bonds=-$L))\n";
	}else{           ######### suppose O(i)-N(j):
	    for($q=1;$q<=$L;$q++){
		printf hh "$hall{2,$q}\n";
	    }
	    $p=$residueR_i{$i};
	    $n=$residueR_j{$i};
	    $RES .="        rsr.add(secondary_structure.sheet(at['O:$p'], at['N:$n'],sheet_h_bonds=-$L))\n";
	}
    }
    close(hh);
  pos80:;
    
    return($RES); #secondary structrure restraints
}


